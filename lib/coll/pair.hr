-- This file is part of the herschel package
--
-- Copyright (c) 2006-2019 Gregor Klinke
-- All rights reserved.
--
-- This source code is released under the BSD License.

module coll
export public (Pair, value-iterator)

import (lang, core)


def record Pair<Car, Cdr>
    ~ Simple LISP like pair/list implementation.

    You can simulate the basic lisp style (cons a b) in herschel with
    Pair(a, b).~
(
  car : Car,
  cdr : Cdr
)


def alias NodePrinterFunc<L, R> = Function(node : Pair<L, R>) -> Unspecified

def generic pair-cell-to-string(node @ Any, port,
                                func : NodePrinterFunc<'L, 'R>) {
  port.writes(" . ")
  port.writes(node.to-string)
}


def pair-cell-to-string(node @ Pair<'L, 'R>, port,
                        func : NodePrinterFunc<'L, 'R>) {
  port.writes(" ")
  func(node)
}


def lang.to-string(self @ Pair<'L, 'R>) -> String {
  if (self.car.nil? and self.cdr.nil?)
    "()"
  else {
    let port = io.StringPort()
    let printer(p : Pair<'L, 'R>) -> Unspecified {
      port.writes(p.car.to-string)

      let pcdr = p.cdr
      if (pcdr <> nil)
        pcdr.pair-cell-to-string(port, printer)
    }

    port.writes("(")
    printer(self)
    port.writes(")")

    port.to-string
  }
}


def alias LPair<T> = Pair<T, LPair<T>>

def alias PairIteratorAccessorFunc<T> = Function(node : LPair<T>) -> T

def record PairIterator<T, Accessor<T>> : Iterator<T>
(
  current : LPair<T>,
  accessor : Accessor
)


def core.next(self @ PairIterator<'Elt, 'AccType>) -> 'Elt {
   if (self.more?) {
     let value = self.accessor(self.current)
     self.current = self.current.cdr
     value
   }
   else
     eof
}


def core.more?(pair @ PairIterator<'Elt, 'AccType>) -> Bool {
   not pair.current.nil? and pair.current.kind-of?(Pair)
}


def value-iterator(pair @ LPair<'Elt>) -> Iterator<'Elt>
    ~ Returns an iterator over the car branches of @var{pair}. ~
{
  PairIterator<'Elt, PairIteratorAccessorFunc<'Elt>>(pair,
                                                     function(node) { node.car })
}


def iterator(pair @ LPair<'Elt>) -> Iterator<'Elt>
    ~ Returns an iterator over all linked nodes of @var{pair} by following
    the cdr chain. ~
{
  PairIterator<'Elt, PairIteratorAccessorFunc<'Elt>>(pair,
                                                     function(node) { node })
}
