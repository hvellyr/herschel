-- This file is part of the herschel package
--
-- Copyright (c) 2010-2011 Gregor Klinke
-- All rights reserved.
--
-- This source code is released under the BSD License.

module lang


extern ("C") {
  struct ATOM h7_allocate_string_n(unsigned int items, Unichar c);
  int h7_lang_string_compare(const struct ATOM atom0, const struct ATOM atom1);
  unsigned int h7_lang_string_length(struct ATOM atom0);
  unsigned int h7_lang_string_char_at_index(struct ATOM atom0, unsigned int idx);
  void h7_lang_string_set_char_at_index(struct ATOM atom0, unsigned int idx, Unichar c);
}

-- builtin strings are really instances of the class @type{StringImpl}.
def record StringSlice : Comparable
(
  str : ^String,
  from : Int,
  to : Int
)




def equal?(one @ StringImpl, two @ StringImpl) -> Bool
  h7_lang_string_compare(one, two) == 0

def unequal?(one @ StringImpl, two @ StringImpl) -> Bool
  h7_lang_string_compare(one, two) <> 0

def less?(one @ StringImpl, two @ StringImpl) -> Bool
  h7_lang_string_compare(one, two) < 0

def greater?(one @ StringImpl, two @ StringImpl) -> Bool
  h7_lang_string_compare(one, two) > 0

def less-equal?(one @ StringImpl, two @ StringImpl) -> Bool
  h7_lang_string_compare(one, two) <= 0

def greater-equal?(one @ StringImpl, two @ StringImpl) -> Bool
  h7_lang_string_compare(one, two) >= 0

def compare(one @ StringImpl, two @ StringImpl) -> Int
  h7_lang_string_compare(one, two) as Int


def num-items(s @ StringImpl) -> Int
  h7_lang_string_length(s) as Int


def slice(s @ StringImpl, idx @ Int) -> Char
  h7_lang_string_char_at_index(s, idx).to-char


def slice*(str @ StringImpl, from @ Int, to @ Int) -> String
  StringSlice(str, from, to)


------------------------------------------------------------------------------
-- Generic implementations for Strings
------------------------------------------------------------------------------

def compare(one @ String, two @ String) -> Int
{
  let result : Int = 0

  for (i : Int in 0 .. one.num-items() - 1,
       j : Int in 0 .. two.num-items() - 1,
       result == 0) {
    result = (one[i] <=> two[j])
  }

  if (result == 0)
    one.num-items() <=> two.num-items()
  else
    result
}


def empty?(str @ String) -> Bool
  str.num-items() == 0

def length(str @ String) -> Int
  str.num-items()

def concat(left @ String, right @ String) -> String
{
  let t = h7_allocate_string_n(left.num-items() + right.num-items(), \space) as String
  let j = 0

  if (left.num-items() > 0) {
    for (i : Int in 0 .. left.num-items() - 1) {
      h7_lang_string_set_char_at_index(t, j, left[i])
      j = j + 1
    }
  }

  if (right.num-items() > 0) {
    for (i : Int in 0 .. right.num-items() - 1) {
      h7_lang_string_set_char_at_index(t, j, right[i])
      j = j + 1
    }
  }

  t
}

def to-string(o @ String) -> String
  o


------------------------------------------------------------------------------
-- Slice special for string
------------------------------------------------------------------------------

def num-items(sl @ StringSlice) -> Int
  sl.to - sl.from

def slice(sl @ StringSlice, idx @ Int) -> Char
  sl.str[sl.from + idx]

def slice*(sl @ StringSlice, from @ Int, to @ Int) -> String
--  if (from > sl.num-items() or to > sl.num-items())
--    OutOfBoundsException(sl.num-items(), from, to).raise
  StringSlice(sl.str, sl.from + from, sl.from + to)
