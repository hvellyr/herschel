-- This file is part of the herschel package
--
-- Copyright (c) 2010-2011 Gregor Klinke
-- All rights reserved.
--
-- This source code is released under the BSD License.

module lang

import "lang/string.h7"
import "lang/stdlib.h7"
import "lang/copyable.h7"
import "lang/sliceable.h7"

extern ("C") {
  int lang_string_compare(const struct ATOM atom0, const struct ATOM atom1);
  unsigned int lang_string_length(struct ATOM atom0);
  unsigned int lang_string_char_at_index(struct ATOM atom0, unsigned int idx);
}


def lang|equal?(one @ String, two @ String) : Bool
  lang_string_compare(one, two) == 0

def lang|unequal?(one @ String, two @ String) : Bool
  lang_string_compare(one, two) <> 0

def lang|less?(one @ String, two @ String) : Bool
  lang_string_compare(one, two) < 0

def lang|greater?(one @ String, two @ String) : Bool
  lang_string_compare(one, two) > 0

def lang|less-equal?(one @ String, two @ String) : Bool
  lang_string_compare(one, two) <= 0

def lang|greater-equal?(one @ String, two @ String) : Bool
  lang_string_compare(one, two) >= 0

def lang|compare(one @ String, two @ String) : Int
  lang_string_compare(one, two) as Int


def lang|length(s @ String) : Ordinal
    lang_string_length(s) as Ordinal

def empty?(str @ String) : Bool
  ~ Indicate whether @var{str} is an empty string. ~
  str.length == 0u


def slice(s @ String, idx @ Ordinal) : Char
  lang_string_char_at_index(s, idx).to-char



------------------------------------------------------------------------------
-- Slice special for string
------------------------------------------------------------------------------

def class StringSlice(_str : String,
                      _from : Ordinal,
                      _to : Ordinal) : OrderedSliceable<Ordinal, Char>
{
  def slot str : String = _str
  def slot from : Ordinal = _from
  def slot to : Ordinal = _to
}


def num-items(sl @ StringSlice) : Ordinal
  sl^to - sl^from


def empty?(sl @ StringSlice) : Bool
  sl.num-items == 0u

def slice(sl @ StringSlice, idx @ Ordinal) : Char
  sl^str[sl^from + idx]

def slice*(sl @ StringSlice, from @ Ordinal, to @ Ordinal) : OrderedSliceable<Ordinal, Char>
  StringSlice(sl^str, sl^from + from, sl^from + to)


def slice*(str @ String, from @ Ordinal, to @ Ordinal) : OrderedSliceable<Ordinal, Char>
  StringSlice(str, from, to)


when ignore {
def class StringImpl : String
{
  def slot data : Char[]
}


------------------------------------------------------------------------------
-- String implementation
------------------------------------------------------------------------------

def length(str @ StringImpl) : Ordinal
  str.data.num-items


def empty?(str @ StringImpl) : Bool
  str.data.num-items == 0


def core|slice(str @ StringImpl, from @ Ordinal, to @ Ordinal)
    : Slice<Ordinal, Char>
  if (from > str.data.num-items or to > str.data.num-items)
    OutOfBoundsException(str.data.num-items, from, to).raise
  StringSlice(str, from, to)


def compare(one @ StringImpl, two @ StringImpl) : Int
  one.data <=> two.data

} -- end of ignore


-- end of impl/string
