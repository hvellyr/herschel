-- This file is part of the heather package
--
-- Copyright (c) 2006-2010 Gregor Klinke
-- All rights reserved.
--
-- Redistribution and use in source and binary forms, with or without
-- modification, are permitted provided that the following conditions are
-- met:
--
-- - Redistributions of source code must retain the above copyright notice,
--   this list of conditions and the following disclaimer.
--
-- - Redistributions in binary form must reproduce the above copyright
--   notice, this list of conditions and the following disclaimer in the
--   documentation and/or other materials provided with the distribution.
--
-- - Neither the name of the author nor the names of other contributors may
--   be used to endorse or promote products derived from this software
--   without specific prior written permission.
--
-- THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
-- IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
-- TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
-- PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
-- OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
-- EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
-- PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
-- PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
-- LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
-- NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-- SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

namespace coll ("eyestep/heather 1.0:collections")

export public(List,
              add, add-all, contains?, empty!, empty?, first, for-each,
              has-all?, index-of, insert, iterator, last, num-items,
              remove, remove-all, remove-at, retain-all, reverse,
              reverse!, size, slice, slice, slice!, sort, sort!, swap,
              to-string)


import(collection)

def private find-last-node(node : @Pair) : node.Type
  let p = node
  if (p <> #nil) {
    while (p.cdr <> #nil)
      p = p.cdr
  }
  p


def class List<Elt>(root: _root : Pair<car: Elt, cdr: _.Type> = #nil)
    : Sequence<Elt>
{
  slot root : Pair<car: Elt, cdr: _.Type> = _root
  slot last : Pair<car: Elt, cdr: _.Type> = #nil

  on init(self) {
    -- set self.last to the last element in the list
    self.last = find-last-node(self.root)
  }
}


def insert(self : @List,
           value : @self.Type.Elt,
           before-index : Int) : self.Type
  select () {
    (before-index == -1) -> {
      let nl = Pair<car: self.Type.Elt>(car: value)
      if (self.last == #nil)
        self.root = self.last = nl
      else {
        self.last.cdr = nl
        self.last = nl
      }
      self
    }

    (before-index == 0 and self.root == #nil) -> {
      self.root = self.last = Pair<car: self.Type.Elt>(car: value)
      self
    }

    otherwise -> {
      let p = self.root
      let prev = #nil
      let n = 0

      while (p <> #nil) {
        if (n == before-index) {
          if (prev <> #nil)
            prev.cdr = Pair<car: self.Type.Elt>(car: value, cdr: p)
          else
            self.root = Pair<car: self.Type.Elt>(car: value, cdr: p)
          return(self)
        }

        prev = p
        p = p.cdr
        n.incr!
      }

      OutOfRangeException("index %d is beyond %d" % #[index,
                                                      self.num-items]).raise
    }
  }


def remove-at(self : @List, index : Int) : self.Type.Elt
  let p = self.root
  let prev = #nil
  let n = 0

  while (p <> #nil) {
    if (n == index) {
      if (prev <> #nil) {
        prev.cdr = p.cdr
        if (p.cdr == #nil)
          self.last = prev
      }
      else {
        self.root = p.cdr
        if (p.cdr == #nil)
          self.last = #nil
      }

      return(self)
    }

    prev = p
    p = p.cdr
    n.incr!
  }

  OutOfRangeException("index %d is beyond %d" % #[index,
                                                  self.num-items]).raise


def add(self : @List, elt : @self.Type.Elt) : self.Type
  self.insert(elt, -1)


def remove(self : @List, elt : @self.Type.Elt) : self.Type
  let idx = self.index-of(elt)
  if (idx >= 0)
    self.remove-at(idx)
  self


def index-of(self : @List, elt : @self.Type.Elt) : Int
  let p = self.root
  let n : Int = 0

  while (p <> #nil) {
    if (p.cdr == elt)
      return(n)
    p = p.cdr
    n.incr!
  }
  return(-1)


def contains?(self : @List, elt : @self.Type.Elt) : Bool
  self.index-of(elt) >= 0


def size(self : @List) : Int
  let n : Int = 0
  for (p = self.root then p.cdr while p <> #nil)
    n.incr!(p.car.size)
  n


def num-items(self : @List) : Int ...
  let n : Int = 0
  for (p = self.root then p.cdr while p <> #nil)
    n.incr!
  n


def empty?(self : @List) : Bool
  self.root == #nil


def empty!(self : @List) : self.Type
  self.root = self.last = #nil
  self


def first(self : @List) : self.Type.Elt
  if (self.root <> #nil)
    self.root.car
  else
    #eof


def last(self : @List) : self.Type.Elt
  if (self.last <> #nil)
    self.last.car
  else
    #eof


def for-each(self : @Collection, func : ForEachVisitor) : self.Type
  for (p = self.root then p.cdr while p <> #nil)
    func(p.car)
  self


def iterator(self : @List) : Iterator(self.Type.Elt) ...
  PairIterator<self.Type.Elt,
               AccessorType: (Function(node : self.Type) : self.Type.Elt)>(
    self.root, #function(node) { node.car })


def meth add-all(self : @List, other : @Collection) : self.Type
  for (e = other.iterator)
    self.add(e)
  self


def meth has-all?(self : @List, other : @Collection) : Bool
  for (e = other.iterator) {
    if (not(self.contains?(e)))
      return(#f)
  }
  #t


def meth retain-all(self : @List, other : @Collection) : self.Type ...
  -- TODO


def meth remove-all(self : @List, other : @Collection) : self.Type
  for (e = other.iterator) {
    self.remove(e)
  }
  self


def meth swap(self : @List, from-idx : Int, to-idx : Int) : self.Type ...
  -- TODO


def private merge-split(nl : Pair) : Pair
  let split-h(nl, nl1, nl2) {
    if (nl == #nil or nl.cdr == #nil)
      Pair(car: nl2.reverse, cdr: nl1)
    else
      split-h(nl.cdr.cdr, nl1.cdr, Pair(car: nl1.car, cdr: nl2))
    }
  }
  split-h(nl, nl, Pair())


def private merge(pred : (Function(left, right) : Bool),
                  nl1 : Pair, nl2 : Pair) : Pair
  select () {
    (nl1 == #nil) -> nl2
    (nl2 == #nil) -> nl1
    pred(nl1.car, nl2.car) -> Pair(car: nl1.car,
                                   cdr: merge(pred, nl1.cdr, nl2))
    otherwise -> Pair(car: nl2.car,
                      cdr: merge(pred, nl1, nl2.cdr))
  }


def private merge-sort(nl : Pair,
                       pred : (Function(left, right) : Bool)) : Pair
  select () {
    (nl == #nil) -> nl
    (nl.cdr == #nil) -> nl
    otherwise -> {
                   let splits = merge-split(nl)
                   merge(pred, merge-sort(splits.car, pred),
                               merge-sort(splits.cdr, pred))
                 }
  }


def meth sort(self : @List, pred : @(Function(left, right) : Bool)) : self.Type
  self.Type(root: merge-sort(self.root, <=))


def meth sort!(self : @List) : self.Type ...
  self.root = merge-sort(self.root, <=)
  self.last = find-last-node(self.root)
  self


def reverse(self : @List) : self.Type
  let newlist = self.Type()
  for (p = self.root then p.cdr while p <> #nil)
    newlist.insert(p.car, 0)
  newlist


def reverse!(self : @List) : self.Type
  let newroot = #nil
  if (self.root <> #nil) {
    newroot = self.last = Pair<self.Type.Elt>(car: self.root.car, cdr: #nil)

    for (p = self.root.cdr then p.cdr while p <> #nil)
      newroot = Pair<self.Type.Elt>(car: p.car, cdr: newroot)
    self.root = newroot
  }
  self


-- operators [] and [] =
def slice(self : @List, index : @Int) : self.Type.Elt
  let n : Int = 0
  for (p = self.root then p.cdr while p <> #nil) {
    if (n == index)
      return(p.car)
    n.incr!
  }
  OutOfRangeException("index %d is beyond %d" % #[index, n]).raise


def slice(self : @List, from : @Int, to : @Int) : Collection<self.Type.Elt>
  let n : Int = 0
  let result = self.Type()

  for (p = self.root then p.cdr while p <> #nil) {
    if (n >= from) {
      result.add(p.car)
      if (n >= to)
        return(p.car)
    }
    n.incr!
  }
  OutOfRangeException("index %d is beyond %d" % #[index,
                                                  self.num-items]).raise


def slice!(self : @Sequence,
           index : @Int,
           value : @self.Type.Elt) : self.Type
  let n : Int = 0
  for (p = self.root then p.cdr while p <> #nil) {
    if (n == index) {
      p.car = value
      return(self)
    }
  }
  OutOfRangeException("index %d is beyond %d" % #[index,
                                                  self.num-items]).raise


def to-string(self : @List) : String
  if (self.root == #nil)
    "()"
  else
    self.root.to-string


-- end of List
