-*-org-*-

Documentation

  - Write nested modules section.

  - rewrite exporting, visibility, and importing section

  - Mention explicitely: coercing.  Where? 

  - Write assignment section.

  - Rewrite the "def xxx" to the new deffn-form-example style.

  - document call-by-value, reference types.


Bootstrap compiler

  - how to allocate multiple dimension arrays?  Int[][]() is of type
    Int[][], what is the allocate* function for this?  Cf. disabled test in
    annotate/array-03.hea

  - allocate of arrays with generic types

      def foo(a @ 'T[],
              new-size : Ordinal,
              init-value : 'T = Class<'T>.null-value) : 'T[]
        let t = 'T[](new-size)
        t.init(init-value)
        t

    does not work, if we hardcode the init function of type 'T in the pass2
    rewriting:

      <apply>
      <symbol>lang|allocate*</symbol>
      <args>
      <type ty="'T"/>
      <symbol>T|init</symbol>
      <int ty='lang|Ordinal'>1</int>
      <symbol>new-size</symbol>
      </args>
      </apply>

    There's no function "T|init" and won't every be.  So either we have a
    generic function "init-functor(Class<'T>), or the allocate* function
    must handle this itself.

    See syntax/array-05.hea



  - get rid of nested functions
    - detect closure variable access

    - detect whether nested functions can simply be inlined

    - otherwise lambda lift functions to outside.

  - array access

  - vardef parameters

  - replace the UnitConstant node by a proper Measure() ctor call.  Apply
    the unit transformation inplace (if simple enough).  Register
    unit-transform calls as special functions.

  - enum:
    - construct proper enum constraint type
    - check that init values match the base type

  - extend macro parameter types (like ?a:type-spec)

  - macros
    - subpatterns

  - continue with pexpreval (add the missing operators)

  - docstrings in pass2 -> extracted documentation


Language and ideas:

  - drop the public id from module specs

  - drop the rename facility from the import statement.

  - review fluids.  Do we really need them?  They clash unhealthily with
    threading.

  - clearify: do we support multiple functions with the same base name but
    different parameter counts?

      def generic init(a @ Int) ...
      def generic init(a @ Int, b @ String) ...

  - how to specify class functions (or static functions)

      def generic apply(self @ Abc.class) ... ???
      def generic apply(self @ class(Abc)) ... ???
      def generic apply(self @ Class<Abc>) ... ???

    The notation Class<T> makes actually clear what we are talking about:
    We declare that the class of a type T is actually an instance of the
    meta class Class<T>.  It is therefore naturally to bind methods to this
    meta class.  And of course it doesn't need a compiler/syntax change.

    or a generic attribute approach (cf. def slots):

      def generic apply(self @ Abc) ; class ...

    This would allow also to define class variables (shared) by all
    instances of a class:

      def slot x ; class

  - write up about module/interface.  Review import, export, module, etc.
    See CHANGES.

  - notation for classes and types.  This is required if you need to pass a
    first-class class into a function.  (Isn't this Class<'T> ?)

  - Group export for enum values.  Export an enum type automatically
    exports its defined value items:

    Additional I like to see:

      def enum X { a b c d }
      export public (X)

      =>

      export public (X a b c d)

  - structs ?  Contrary to classes do not support inheritance, but provide
    fixed, controlled, and fast slot layout.

  - Think about non-gc objects.

  - Think about lazy evaluation (generalize the 'promise' concept
    introduced en passent with sync).  See x10 -> futures.

  - checked exceptions.  Declare as

      def generic f() : 'X
          raises 'B
          reify () : N, () : P
          where B isa Throwable
        ...

    additionally

      def generic f() : 'X
          no-raise
          reify ....

    to document that a function does not pass exceptions.



