-*-text-*-

Herschel 2

  - generate finalizers
    - for local variables in blocks  (DONE)
    - for value-parameters in functions  (DONE)
    - for constructed values pass to reference parameters in functions:

        def foo(a : ^String) ...

        foo(String("abc"))

        >>>

        let __tmp_1 : String
        init-move(__tmp_1, "abc")
        foo(__tmp_1)
        deinit(__tmp_1)

      this has to be done for default initializers, too

  - finish record parsing/code generation

    - add <generics> to macro
    - rethink: do we really need a <generics> list on record types?
      Wouldn't 'T usage in fields be more consistent?
    - if so adapt the parser/type check to handle 'Ts in record defs

    - rename record to __record, the macro xrecord to record

    - add function/code attributes
      - auto/volatile - such methods/functions will be dropped in
        favour of user defined ones.  -> allows simple over writting
        of methods/functions by the user

    - doesn't parse in the moment:

      def xrecord Xaz (
        f : Function(a : ^String)
      )

      neither does:

      def xrecord Xaz (
        f = function(a : ^String) { unspecified }
      )

  - memory management, reference types, ...
    - rethink Any typed variables

    - document/take the following matrix

                                var is on stack     var is ptr to heap
       base types (int, bool)        x
       record types                  x
       interface types                                     x
       any type                                            x
       ref to base type                                    x
       ref to record                                       x
       ref interface                                       x
       ref to any                                          x

  - implement 'mut'
  - implement '&' syntax
  - implement syntax "let a : ^ = ^Foo()" and "let a : & = &Foo()"

x   + remove inheritance from record types.  Only interfaces can inherit.
x   + record types are always concrete types

    + change (local) variable setup with "creating a new instance"
      from "var def is initializing", to a more imperative style:
      + define a local var with a proper type as "undef"
      + if the type is
        + a base type: set to default value
        + a concrete (record) type: call the concrete .Foo.init(...) initializer with the local var
        + an interface or any type: -> Error (since generic types can't be instantiated)
        + a reference type: -> Error
      + when the init value is some other value or expression: keep the current style.

    - generating copy occurances.  with a = b  and
      - a and b are the same base type: simply copy the base value
      - a and b are of different base type: ERROR
      - a and/or b are references to the same base type: simply copy the base value with
        appropriate de-referencing
      - a and b are the same concrete (record) type call the concrete copy operator .Foo.copy-assign(a, b)
        (which sets a in place)
      - a and b are different concrete types: ERROR
      - a and/or b are references to the same concrete (record) types: call the concrete copy
        operator .Foo.copy-assign(a, b) with appropriate de-referencing
      - b is an interface or any type: call the generic function copy(b @ ...), assign the ptr result
      - a and/or b are references to interface or any types: call the generic function
        copy(b @ ...), assign the ptr result

    - generating move occurances.  with a = b  and
      - a and b are the same base type: simply copy the base value
      - a and b are of different base type: Error
      - a and/or b are references to the same base type: simply copy the base value with
        appropriate de-referencing
      - a and b are the same concrete (record) type call the concrete move operator .Foo.move(a, b)
        (which sets a in place)
      - a and b are different concrete types: error
      - a and b are references to the same concrete (record) types: assign the ptr of b to a
      - a or b are references to the same concrete (record) types: call the concrete move
        operator .Foo.move(a, b) with appropriate de-referencing
      - a and b are interface or any types: assign the ptr of b to a
      - a and/or b are references to interface or any types: assign the ptr of b to a

    - in case of destruction if a member/variables is
      - a base type: do nothing
      - a concrete (record) type: make calls to destructors concrete: .Foo.deinit(...)
      - an interface or any type: call the generic function deinitialize(x @)
      - a reference type: do nothing
    - create the virtual overload for deinitialize(x @ Foo) which calls the concrete .Foo.deinit(...)


  + create proper constructors (see below)
    - check init calls to slots in array type creation
  - generate finalizer() calls for variables going out of scope (RAII)
    + need to capture the return value of a block in a local variable,
      then add the finalizer calls, then return that local variable.
      When generating the finalizers this local variable must not be
      destructed of course (look for reference types, etc.!)
    + don't call allocate or deallocate in constructor/destructor
      calls.  Only init() and deinitialize()
    + generateFinalizers for functions params

  - reference types, ref-counted types, pointer dereferencation
  - "mut" modifier
  - rewrite operators +=, *=, ++=, ... to set!( ....) etc.

x - modifiers "pub", "intern", "private"
x - remodel import/export/module system
x - add "include" /import
x - finish slot syntax compilation
x - fix a.foo() -> foo(a) syntax
x - method overloading
x - keyed parameter behaviour of .init functions for records
x - change "extends { }" to "with ns { }"
x - clarify isQualified() -> does it mean rooted?
x - simplify for-loop to support one test-expr only.
x - "while" loops
x - Token(typeIntroToken.srcpos(), kSymbol, "Any")
x - rename in code union types -> variant types, seq types -> intersection types
x - remove unicode macro delimiter
x - re-design macro syntax
x - transform slot access syntax
x - unify namespace, slot, method notation
x - enum values are per enum, not global symbols.
x - remove the {} around match and select
x  - reduce "for " -> to a simple "for (x in foo)"
x - remove the () around the inheritance type list of records and types
x - def enum () with round paranthesis
x - add on-alloc() hook to generateCtor()
x - transform "class" -> "record"
x   - remove the complexity of class initialization code generation
x - del kExtendId
x - remove "on" machinery
    - remove exceptions
x - remove reify
x - remove units and measures
x - remove slot machinery
x - remove method call shorthand (without parantheses)
x - recognize and rewrite into  ctor/dtor protocol
x - the for loop is rewritten into while + variable definitions too
    early.  Therefor it is not properly detected in tail positions and
    thus type deduction fails in some situations
x - remove record inheritance

? - rename function() to fn(), and the type of it to Fn()
? - remove type constraints (value constraints ...)





----------------------------------------------------------------------------------------

 x   record objects (ADT?)
 x   function oriented
 x   runtime polymorphism (runtime type dispatch, multi-dispatch?)
 x   compile time function overload

     namespaces
     modules

     (hyginene) macros
 x   generic types

 x   type matching

 x   no exceptions.  Error handling is done with return types (maybes, variants, match)




clang –O4 –S –emit-llvm sumarr.c






Various syntax patterns

expression with arguments:

  keyword ( arg, arg, arg )


scope-expression with arguments:

  keyword ( arg, arg, arg) value


value: is

  expression list:

  expr[;] expr[;] expr


option list

  | cond -> result
  | cond -> result


declaration

  def [what] name [modifier modifier modifier] [: type] [= initialization ]
  let [what] name [modifier modifier modifier] [: type] [= initialization ]

  what: const

  modifier: mut
            pub[lic]
            priv[ate]

  def [what] name (param, param, param) body

    what: generic, method, macro

  def what (param, param, param)

  what -> record, type, enum

  def enum (













  A shared pointer implementation:

    def record SharedObjBlock<T> (
      ref-count : int,
      val : T
    )

    def record SharedPtr<T> (
      data : (^SharedObjBlock<T> | Nil) = nil
    )

    -- implementation of = operator
    def set!(lhs : ^SharedPtr<T>, rhs : ^SharedPtr<T>) -> ^SharedPtr<T> {
      match (lhs.data)
        | _ : Nil -> {
                       match (rhs.data)
                         | _ : Nil -> unspecified
                         | rcb : ^SharedObjBlock<T> -> {
                                                         inc!(rcb.ref-count)
                                                         lhs.data^ = rcb
                                                       }
                     }
        | lcb : SharedObjBlock<T> -> {
                                       match (rhs.data)
                                         | _ : Nil -> unspecified
                                         | rcb : ^SharedObjBlock<T> -> inc!(rcb.ref-count)

                                       if (lcb.ref-count == 1)
                                         lhs.data = nil
                                       else
                                         dec!(lcb.ref-count)

                                       match (rhs.data)
                                         | _ : Nil -> unspecified
                                         | rcb : ^SharedObjBlock<T> -> lhs.data^ = rcb
                                    }
      lhs
    }

    -- copy constructor
    def copy(rhs @ ^SharedPtr<T>) -> SharedPtr<T> {
      SharedPtr<T>(data: {
                           match (rhs.data)
                             | _ : Nil -> nil
                             | rcb : ^SharedObjBlock<T> -> {
                                                             inc!(rcb.ref-count)
                                                             rcb
                                                           }
                         })
    }

    -- destructor
    def deinitialize(self : ^SharedPtr<T>) {
      match (self.data)
        | _ : Nil -> unspecified
        | cb : ^SharedObjBlock<T> -> if (cb.ref-count == 1)
                                       lhs.data = nil
                                     else
                                       dec!(cb.ref-count)
    }

    def value(self : ^SharedPtr<T>) -> ^T {
      match (self.data)
        | _ : Nil -> {
                       -- display("Derefencing unset shared pointer")
                       unspecified
                     }
        | cb : ^SharedObjBlock<T> -> cb.val
    }








copy construction
-----------------

    def gen copy(o @ ^'T) -> ^T ...

The compiler will generate on-copy methods for each type like this:

    def copy(o @ ^Foo) {
      -- let t = .Foo.init(.lang.allocate(.lang.Type<Foo>),
      --                   .lang.copy(o.first)
      --                   .lang.copy(o.first))
      let t = Foo(nm: o.nm)
      .Foo.on-copy(t, o) <<opt>>
      t
    }


-> change to

The compiler will generate a copy method for each type like this:

    def copy(o @ ^.Foo) {
      optional (if .Foo.copy is defined):
        Foo(nm: o.nm)
      or:
        .Foo.copy(o)
    }

    def .Foo.copy(o @ ^.Foo) -> ^.Foo {
      ...
    }


Copy assign construction:

The compiler will generate a copy-assing method for each type like this:

   def .Foo.copy-assign(self : ^.Foo, rhs : ^.Foo) -> ^.Foo {
     self.nm = rhs.nm
     self
   }

If the user provides a .Foo.copy-assign() function the compiler won't.


















































































Documentation

  - Write assignment section.

  - Document how to specify class functions:

      def generic apply(self @ Class<Abc>) ... ???

  - Mention explicitely: coercing.  Where?

  - document call-by-value, reference types.

  - rewrite the operator section

  - document array allocation (i.e. document the allocate* function call,
    and its special syntax):

    Int[](16)                      -> allocate array of 16 Ints
    Person[](4, value: Student())  -> explicit init value, all slots refer
                                      to same object
    Student[](5)                   -> allocates 5 student instances

  Formating:

    - Rewrite the "def xxx" to the new deffn-form-example style.


Bootstrap compiler

  - extend tests for the other intx types

  - other types (char, bool, int8, uint8, int16, uint16, uint32, int64,
    uint64, float, double)

  - char binary operators
  - char arrays

  - basic IO classes (such to allow displaying info from test files)

  - gc

  - closures (nested functions, firstclass functions)

  - keyed arguments

  - rest arguments
    - builtin slice support for arrays (required for fast rest parameter handling)

  - exceptions

  - auto create accessor/modifier functions for slots

  - support 'public', 'outer', 'inner', slots in ctor construction.

  - variable/const types

  - nullable types

  - review possibilities for warnings about ambiguous multiple method
    dispatch.  better method dispatch algorithm.

  - check that left hand variables are not const.

  - review some kind of auto-number coercion?

  - 'T are treated as Any inside of function body for direct comparison
    and need type-check boundaries at runtime.  The type checker must make
    sure that a 'T is only assigned to 'T and not 'K or 'V.

  - reference types.
     - type checks.  When is T = ^T allowed?
     - do we need a special syntax for dereferencing references?
     - review special construct to check whether a ^T is nil or not?
       if (a as* T == nil)

       def foo(a : ^String)
         let x : String = enforce(a, "a is nil")    ;; throws an exception
         let x : String = saferef(a, "n.n.")        ;; returns a or "n.n."

     - how to express nil-ness with the normal type machine


  - do an error counter and stop after xxx errors.  Generally don't go into
    real compilation, when we found (severe) errors.  LLVM crashes too easily.

  - constraints

  - BUG: syntax errors from import files are not shown (handled) properly.

  - BinaryNode: in case the builtin types are not recognized from the
    compiler, lookup an add(), subtract(), multiply(), ... function and use
    its type signature to check whether the binary operator is possible and
    correct.

    The same for binary compare operators.

    The same for append(), fold()

  - transform nested functions
    - detect closure variable access

    - detect whether nested functions can simply be inlined

    - otherwise lambda lift functions to outside.

  - extend macro parameter types (like ?a:type-spec)

  - macros
    - subpatterns

  - continue with pexpreval (add the missing operators)


Other tools

  - docstrings in pass2 -> extracted documentation


Language and ideas:

  - structs ?  Contrary to classes do not support inheritance, but provide
    fixed, controlled, and fast slot layout.  Structs will use the same
    syntax for member access:

    def struct Element {
      def slot a : Int
      def slot b : String
    }

    let e : Element
    e.a = 42
    e.b = "The question"


  - Think about lazy evaluation (generalize the 'promise' concept
    introduced en passent with sync).  See x10 -> futures.  (cf. doc/CHANGES)





--------------------------------------------------------------------------------

We need to add atomic stuff to the language.

  - look into https://llvm.org/docs/LangRef.html#memory-model-for-concurrent-operations
  - compare rust's std::sync::atomic  (https://doc.rust-lang.org/std/sync/atomic/)

  As separate type (wrapper):

    let x : lang.atomic.Atomic<Int>

    x.load(lang.Ordering.seqcst)     -- = lang.atomic.load(x, lang.Ordering.seqcst)
    x.store(lang.Ordering.acquire)   -- = lang.atomic.store(x, lang.Ordering.acquire)


  Maybe with variable annotation syntactic sugar:

    let x atomic : Int = ...         -- rewrites into the above


  fences?

    .lang.atomic.fence(lang.Ordering::Acquire)







    Herschel                            C
-------------------------------------------------------------
!   identifier                          not
    (modifier function marker)
"   string delimiter                    string delimiter
#   keyword notation                    preproc
    constant array notation
$   identifier                          [----------]
%   identifier                          operator (mod)
    operator (fold)
&                                       operator (&, &&)
                                        pointer ref op.
'   implicit type generics              char
()  arguments                           arguments
    grouping                            grouping
    record slot list
    complex types
*   operator (*, **)                    operator(*)
    identifier                          pointer ref op.
+   operator (+, ++)                    operator(+, ++)
    identifier
,   parameter separator                 parameter separator
-   identifier                          operator (-)
    operator (-)
    negative numbers
.   function call                       struct member
    slot member
    enum member                         enum member
    float notation                      float notation
    operator (..)
    vararg notation (...)               vararg notation (...)
/   operator (div)                      operator(div)
    identifier
0-9 digits                              digits
    identifier                          identifier
:   keyword arguments                   ternary operator
    type separator
;   stmt terminator                     stmt terminator
<>  operator (<, >, <=, >=, <>, ->)     operator(...)
    type parametrization
=   operator (==, <=, >=)               operator(==)
    assignment                          assignment
    parameter default
?   identifier                          ternary operator
    (predicat function marker)
    macro variable marker (?...)
@   specialize marker                   [----------]
A-Z identifier                          identifier
    digits (A-F)                        digits (A-F)
[]  slicing                             array
    arrays
\   char constants                      escaping
^   call-by-reference (^type)           operator (xor)
    dereference variables (abc^)
_   identifier                          identifier
`   [----------]                        [----------]
a-z identifier                          identifier
    digits (a-f)                        digits (a-f)
{}  code block                          code block
|   union type separator                operator ( |, ||)
    select/match/macro case marker
~   docstring limiter                   operator (bit not)
«»  macro block (alt: ?(, )?)







Links:
https://pauladamsmith.com/blog/2015/01/how-to-get-started-with-llvm-c-api.html
https://github.com/paulsmith/getting-started-llvm-c-api/blob/master/sum.c
http://llvm.org/doxygen/group__LLVMC.html

look into clang+llvm/include/llvm-c/















on signal (break-signal : BreakSignal)
{
  foo
  bar
  raise(BreakSignal(...))
}

on exit (v) { ... v }
if (test) exit(42)

on signal
  | break(v : Int) -> { ... v }
{
  if (test)
    break(42)
}


match (v)
  | x : Bool -> ...
  | _ : Any -> ...

with | break(v : Int) -> { ... v }
{
  if (test)
    break(42)
}


with namespace foo { ... }

with signals
  | break(v) -> { ... }
  | bar(v) -> { ... }
{
  if (foo) break(42)
}


def class BreakSignal(val)
{
  def slot return-value = val
}


def macro with-break
  | « with-break() ?body:expr »
    -> « {
           on signal (break-signal : BreakSignal) {
             break-signal.return-value
           }
           let break(retval) {
             BreakSignal(retval).raise
           }
           ?body
         } »
  | « with-break(?break:name) ?body:expr »
    -> « {
           on signal (break-signal : BreakSignal) {
             break-signal.return-value
           }
           let ?break(retval) {
             BreakSignal(retval).raise
           }
           ?body
         } »
  | « with-break(?break:name = ?func:expr) ?body:expr »
    -> « {
           on signal (break-signal : BreakSignal) {
             break-signal.return-value
           }
           let ?break(retval) {
             BreakSignal(?func (retval)).raise
           }
           ?body
         } »






















def .lang.copy (%(o @ %(^ .Person %) %) ) -> Any
{
  %(let t = %(on-copy (%(%(.Person.init (%(.lang.allocate (%(.lang.Type <.Person > %) ) %) , idaddr ) %) . Person %) t , o ) %) %) t
}





def record String
(
  data : Char[],
  length : Int
)

For each type create these functions:


  def String.init(o : ^String, data -> d = Char[](), length -> l = 0) -> ^String
  {
    Array.init-move(o.data, d)
    o.length = l
    o
  }

  def String.init-copy(o : ^String, rhs : ^String) -> ^String
  {
    Array.init-copy(o.data, rhs.data)
    o.length = rhs.length
    o
  }


  def String.init-move(o : ^String, rhs : ^String) -> ^String
  {
    Array.init-move(o.data, rhs.data)
    o.length = rhs.length
    o
  }

  def String.deinit(o : ^String)
  {
    Array.deinit(o.data)
  }


  def String.copy(lhs : ^String, rhs : ^String) -> ^String
  {
    let t : String = undef
    String.init-copy(t, rhs)
    String.deinit(lhs)
    String.init-move(lhs, t)
  }


  def String.move(lhs : ^String, rhs : ^String) -> ^String
  {
    let t : String = undef
    String.init-move(t, rhs)
    String.deinit(lhs)
    String.init-move(lhs, t)
  }


  def lang.copy(lhs @ ^String, rhs @ ^String) -> ^String
  {
    String.copy(lhs, rhs)
  }

  def lang.move(lhs @ ^String, rhs @ ^String) -> ^String
  {
    String.move(lhs, rhs)
  }

  def lang.deinit(o @ ^String)
  {
    String.deinit(o)
  }

  def lang.null-value(o @ Type<String>)
  {
    String()
  }


  /*
    For:

      def record Id
      (
        name : String,
        id-number : Int
      )

    generate:

      def .lang.init-functor(o @ .lang.Type<.Id>, rest... : .lang.Any) -> ^.Id
        let t = function(c : ^.Id, rest1...) -> ^.Id
          {
            let r1 = .Id.init(.lang.allocate(c),
                              name = { let t2 = .lang.assoc(rest1, #name)
                                       let r2 = if (.lang.isa?(t2, .lang.Type<.lang.String>))
                                                  t2 as .lang.String
                                                else {
                                                  let i5 : .lang.String
                                                  .lang.String.init(i5,
                                                                    data = .lang.null-value(.lang.Char[]>),
                                                                    length = .lang.null-value(.lang.Type<.lang.Int32>))
                                                  i5
                                                }
                                       r2
                                     },
                              id-number = {
                                            let t3 = .lang.assoc(rest1, #id-number)
                                            let r3 = if (.lang.isa?(t3, .lang.Type<.lang.Int32>))
                                                       t3 as .lang.Int32
                                                     else
                                                       .lang.null-value(.lang.Type<.lang.Int32>)
                                            r2
                                          })
            r1
          }
        t
  */







A call like

  let x = String()


is translated:

  let x : String = undef
  String.init(x, data = Char[](), length = 0)

And

  let a : String
  let b : String

  a = b

is translated as:

  let a ...
  let b ...
  String.copy(a, b)


Copies in function calls:

  let foo(a : String = "abc") ...

  foo()

->

  {
    let t : String = undef
    String.init-copt(t, "abc")
    foo(a = t)
  }





def record Id
(
  name : String,
  id-number : Int
)


def Id.init(obj : ^Id,
            name -> p1 : lang.String = { let i1 : lang.String
                                         lang.String.init(i1,
                                                          data = lang.null-value(lang.Type<lang.Char[]>),
                                                          length = lang.null-value(lang.Type<lang.Int32>))
                                         i1
                                       },
            id-number -> p2 : lang.null-value(lang.Type<lang.Int32>))
  -> ^Id
{
  obj.name = p1
  obj.id-number = p2
  obj
}


def Id.copy(lhs : ^Id,
            rhs : ^Id) -> ^Id
{
  lang.String.copy(lhs.name, rhs.name)
  lhs.length = rhs.length
  lhs
}


def Id.move(lhs : ^Id,
            rhs : ^Id) -> ^Id
{
  lang.String.move(lhs.name, rhs.name)
  lhs.length = rhs.length
  lhs
}


def lang.copy(o @ ^Id)
{
  let t = Id.init(lang.allocate(lang.Type<Id>),
                  name = {
                           let s1 = lang.String
                           lang.String.init(s1,
                                            data = o.name.data,
                                            length = o.name.length),
                         }
                  id-number = lang.copy(o.id-number))
  Id.on-copy(t, o) <<opt>>
  t
}


def lang.deinitialize(o @ ^Id) -> ^Id
{
  lang.deinitialize(o.name)
  lang.deinitialize(o.id-number)
  o
}


def lang.init-functor(o @ lang.Type<Id>, rest... : lang.Any) -> ^Id
{
  let t = function(c : ^Id, rest1...) -> ^Id
    {
      let r1 = Id.init(lang.allocate(c),
                       name = { let t2 = lang.assoc(rest1, #name)
                                let r2 = if (lang.isa?(t2, lang.Type<lang.String>))
                                           t2 as lang.String
                                         else {
                                           let i5 : lang.String
                                           lang.String.init(i5,
                                                            data = lang.null-value(lang.Char[]>),
                                                            length = lang.null-value(lang.Type<lang.Int32>))
                                           i5
                                         }
                                r2
                              },
                       id-number = {
                                     let t3 = lang.assoc(rest1, #id-number)
                                     let r3 = if (lang.isa?(t3, lang.Type<lang.Int32>))
                                                t3 as lang.Int32
                                              else
                                                lang.null-value(lang.Type<lang.Int32>)
                                     r2
                                   })
      r1
    }
  t
}



In addition generate:

  compare(lhs : ^Foo, rhs : ^Foo) -> Int ...



Allow assignment/deconstruction of record values into multiple variables:

  let p = Record(...)
  let a, b, c = p
