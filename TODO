-*-org-*-

Documentation

  - Write nested modules section.

  - rewrite exporting, visibility, and importing section

  - Mention explicitely: no coercing.  Where?

  - Write assignment section.

  - Rewrite the "def xxx" to the new deffn-form-example style.

  - document call-by-value, reference types.


Bootstrap compiler

  - get rid of nested functions
    - detect closure variable access

    - detect whether nested functions can simply be inlined

    - otherwise lambda lift functions to outside.

  - array access

  - vardef parameters

  - replace the UnitConstant node by a proper Measure() ctor call.  Apply
    the unit transformation inplace (if simple enough).  Register
    unit-transform calls as special functions.

  - enum:
    - construct proper enum constraint type
    - check that init values match the base type

  - extend macro parameter types (like ?a:type-spec)

  - macros
    - subpatterns

  - continue with pexpreval (add the missing operators)

  - types for count variables in for loop

  - docstrings in pass2 -> extracted documentation


Language and ideas:

  - clearify: do we support multiple functions with the same base name but
    different parameter counts?

      def generic init(a @ Int) ...
      def generic init(a @ Int, b @ String) ...

    If we define ctors to be essentials calls to the class/apply functions,
    we definitely have to (each class than has an apply function).

    If we don't support this, some ideas for ctors:

      def class Ixwick { }
      def ctor Ixwick(cl @ Class<Ixwick>)

    Eek, review the complete ctor/apply/init thing again.


  - how to specify class functions (or static functions)

      def generic apply(self @ Abc.class) ... ???
      def generic apply(self @ class(Abc)) ... ???
      def generic apply(self @ Class<Abc>) ... ???

    The notation Class<T> makes actually clear what we are talking about:
    We declare that the class of a type T is actually an instance of the
    meta class Class<T>.  It is therefore naturally to bind methods to this
    meta class.  And of course it doesn't need a compiler/syntax change.

    or a generic attribute approach (cf. def slots):

      def generic apply(self @ Abc) ; class ...

    This would allow also to define class variables (shared) by all
    instances of a class:

      def slot x ; class


  - write up about module/interface.  Review import, export, module, etc.
    See CHANGES.

  - notation for classes and types.  This is required if you need to pass a
    first-class class into a function.


  - Group export for enum values.  Export an enum type automatically
    exports its defined value items:

    Additional I like to see:

      def enum X { a b c d }
      export public (X)

      =>

      export public (X a b c d)



  - structs ?  Contrary to classes do not support inheritance, but provide
    fixed (and controlled) layout.

  - Think about non-gc objects.

  - Think about lazy evaluation (generalize the 'promise' concept
    introduced en passent with sync).  See x10 -> futures.

  - checked exceptions.  Declare as

      def generic f() : 'X
          raises 'B
          reify () : N, () : P
          where B isa Throwable
        ...

    additionally

      def generic f() : 'X
          no-raise
          reify ....

    to document that a function does not let exceptions through.

  - Embedding of C/C++ fragments.  Like this:

    extern ("C") {
      void foo();
      int bar(int argc, char** argv);
    }


