Herschel
========

Introduction

  Herschel is a general-purpose programming language that evolved over
  many years and was inspired by features and the "feel" of many
  different programming languages.  Besides other the main influences
  have been Scheme, Dylan, Cecil/Diesel.

  It has a strong functional approach without been strict.  It's main
  characteristics should be

  - allow rapid programming
  - enable conceptually complex software, without being complex on the
    language level
  - allow for performant compilation


0. Basic vocabulary and representation

  Herschel code is written in source files normally taking the
  extension @file{.hr}.  No formal distinction between implementation
  and declaration files (``source'' and ``header'') is imposed by the
  language.  A file can contain any number of modules, types, and
  function definitions.  Technically the language does not impose any
  constraint on the way a source file is to be named or where it is to
  be located; there's especially no coupling of module and folder
  structure or class and file name.

  Source files are expected to be encoded in UTF-8 encoding, no
  normalization is expected or applied though.


0.1 Identifiers

  Identifiers are sequences of letters, digits, and some special
  characters.  Though unicode is used as the normal encoding of source
  files only a restricted set of letters are supported:

    abcdefghijklmnopqrstuvwxyz ABCDEFGHIJKLMNOPQRSTUVWXYZ
    0123456789 - _ * + % ? ! /

  The first character must either be a letter or one of the following
  special characters:

    - > * + %

  Since identifier can start with the same characters which are also
  used for operators it is necessary to add whitespace (space,
  tabulator, newlines) to avoid ambiguities.

  Identifiers are case sensitive.

  Examples:

    MutualString
    to-string
    list-of-values!
    _private-value
    *stdout*
    %CONST%


0.2 Comments

  Comments may be inserted between any two symbols in a program.  They
  are arbitrary character sequences started with @c{--} and reaching
  to the end of the line.  Comments do not affect the meaning of a
  program.

  Examples:

    -- a comment until the end of the line


0.3 Numbers

  Numbers are (unsigned) integers, real, complex, or rational numbers.

  Integers are sequences of digits and may be followed by type or
  signed suffix letters.  If no suffix is specified, the
  representation is decimal.  The suffix @c{h} indicates hexadecimal
  representation, the suffix @c{q} specifies octal, and @c{y} binary.

  A real number always contains a decimal point.  Optionally it may
  also contain a decimal scale factor.  The letter @c{e} is pronounced
  as "times ten to the power of".  A real number is of type @c{real}.

  A rational number contains of two integers separated by a @c{/}
  (without separating whitespace).

  A complex number consists of two parts, a first real or integer and
  a second integer number with an attached @c{i} or @c{j} suffix, both
  glued with a @c{+}.

  Examples:

    100                     -- decimal
    100h                    -- hexadecimal
    100y                    -- binary
    100q                    -- octal

    1234                    -- integer

    123.4                   -- real
    1.23e-45                -- real

    12 + 34i                -- complex
    12.3+34j                -- complex

    12/34                   -- rational


0.4 Characters

  Character constants are denoted either by a name or a unicode
  codepoint number after a leading backslash.  The name is an
  identifier which is assigned with the @c{def char} statement.  The
  unicode codepoint number is a integer directly following a leading
  @c{u} prefix.

  Examples:

    \nl                     -- newline
    \nbsp                   -- no-break-space
    \tab                    -- tabulator
    \u0041h                 -- A
    \u0164q                 -- t


0.5 Strings

  Strings are sequences of characters enclosed in quote marks (@c{"}).
  A string can contain a quote mark, when it's escaped with a
  backslash @c{\}, and any other character using the @c{\} notation.
  Characters like this must be terminated with a @c{;}.

  Examples:

    "abc"                   -- abc
    "hello\space;world"     -- hello world
    "hello\u0020h;world"    -- hello world
    "/\bsol;/"              -- /\/


0.4 Booleans

  Boolean constants are denoted with the identifiers @c{true} and
  @c{false}.


0.5 Keywords

  A keywords is a named enumeration of unclear value, which is though
  identical in all libraries and applications.  It is denoted with a
  @c{#} and a directly following identifier.

  Examples:

    #abc
    #hello-world


0.6 Others

  Some special values are defined and are denoted by the identifiers
  @c{nil}, @c{eof}, and @c{unspecified}.


0.7 Reserved identifiers

  A number of identifiers are reserved by the language and can not be
  used for other purposes.  These are:

    AND
    Function
    OR
    XOR
    and
    as
    by
    def
    else
    export
    extend
    for
    function
    if
    import
    in
    isa
    let
    match
    mod
    module
    nil
    not
    on
    or
    select
    when
    where
    while
    with

  The following identifier are defined by the language and used in
  some context; reusing them for variables or function is possible,
  but with caution:

    application
    char
    config
    const
    enum
    generic
    ignore
    include
    library
    macro
    priv
    private
    pub
    public
    record
    type

0.8 Blanks

  Blanks must not occur within symbols.  Blanks, line breaks, and
  empty lines are ignored otherwise.


1. Memory model

  Types have value semantics; simply assigning makes copies (unless
  the compiler can prove that moving it won't make a difference).  All
  values in tail position can (and will) be moved.

    def foo() {
      let x = 42         -- x initialized to 42
      let y = x          -- x moved into y
      y                  -- y moved out
    }

    def foo(a) {
      let x mut = a      -- a copied to x
      ...

      bar(a)             -- bar called with copy of a
      a                  -- a moved out
    }

  - if the compiler can be sure that a called function will not modify
    a variable value, it can call it with a reference (pointer) to the
    variable.

  - local copies of values can be avoided, if the new variable is only
    a different name for the same value.

1.1. types can be passed by reference explicitly:

    def foo(a : ^Bar) {
      display(a)
    }

  a is a pointer to a variable of type Bar.  Simply using it reads its
  value (not the address).  Assigning values to pointer variables,
  copies (or moves) the value into the pointer destination.  Assigning
  pointers to pointers will deref the one and assign its value to the
  other:

    let a = Student(...)
    let b : ^ = a             -- let b point to a (with type deduction)

    b.name = "Heinz"          -- change a through b
    display(a.name)           -- => "Heinz"

    b = Student(...)          -- copies a new Student value into a (through b)
    let c : ^ = a             -- let c point to a, too
    c = b                     -- copy value of b through c into a (i.e. a == a)

  pointers can never be reset to nil, not being uninitialized.  After
  definition a pointer can only be rebound with a special syntax (see
  below).

  Certain expressions use auto-dereferencing of references.  With two
  bindings - p [pointer] and v [value] - they can be assigned with
  references or not in the following way:

   v1 = v2                   -- copy value of v2 to v1
   v1 = p1                   -- copy value of deref(p1) to v1
   p1 = v1                   -- copy value of v1 into p1
   p1 = p2                   -- copy value of deref(p2) into p1

  with two functions `foov(v:T)` and `foop(p:^T)` the same rules apply:

   foov(v)                   -- call foov with a copy of v
   foov(p)                   -- call foov with a copy of deref(p)
   foop(v)                   -- call foop with a reference to v
   foop(p)                   -- call foop with p as reference

1.2 Rebinding pointers

  Pointers can be reset to other variables:

   p1^ = v1                  -- set p1 to refer to v1
   p1^ = p2                  -- let p1 point to the same value as p2

  Caution! This allows to produce undefined behaviour, but is
  necessary to implement shared pointers etc.

  Attention:

    def foo(a:^) {
      let b = Student()
      a = b                  -- copies value of b through a into the caller
    }

    def foo(a:^) {
      let b = Student()
      a^ = b                 -- resets a to point to b. original a is not accessible anymore
    }

    def foo() -> ^ {
      let b = Student()
      b                      -- ERROR: returns reference to local variable
    }

    def const sentinel
    def record Obj ( _ref : ^ = sentinel )

    def foo(o:^) {
      let b = Student()
      o._ref^ = b            -- ERROR: o._ref points to local variable
    }


1.3. ref-counted objects

  Adding a & to a type makes it a ref-counted, heap-allocated type.
  It's actually syntactic sugar and rewritten into SharedPtr<T> by the
  compiler:

    let a : &Foo          =>   let a : .lang.SharedPtr<Foo>
    let a : & = Foo(42)   =>   let a : .lang.SharedPtr<Foo> = make-shared(Foo(42))

  Assigning and accessing is handled transparently by the compiler by the
  access/cast operator:

    def value(self @ ^.lang.SharedPtr<'T>, as-type : Type<'U>) -> ^'U {
      self.cb.val as 'U
    }

  This value is used for instance when

    let b : &String
    let a : String = b

  Shared pointers are reference counted owner pointers holding a
  value.  The reference counter is not intrusive, but organized by the
  SharedPtr class itself.

    let a = &Bar()
    let b = a                 -- a and b point to the same object, with shared
                                 ownership.

    let a = Bar()
    let b : & = a             -- a is copied into the shared pointer of b. a is
                                 still a value.

    let a : &Bar              -- a is a shared ptr, with a default initialized Bar()
    let a : & = Bar()         -- the same

    let a : (&Bar | Nil) = nil  -- shared ptr to a Bar|Nil initialized to nil.
    let a : (&Bar | Nil)      -- ERROR: a is uninitialized


1.4. relation of pointers and ref-counted objects

  let a : Bar            -- default initialized stack value
  let a = Bar()          -- default initialized stack value
  let a : &Bar           -- shared pointer object (default initialized)
  let a : & = Bar()      -- shared pointer object (default initialized)
  let a = &Bar()         -- shared pointer object (default initialized)
  let a : & = p          -- shared pointer object (copy p.get() to a; a + p have shared object)
  let a : & = v          -- shared pointer object (copy v to a)
  let a : ^              -- ERROR: uninitialized + untyped reference
  let a : ^Bar           -- ERROR: uninitialized reference
  let a : ^Bar = b       -- reference to variable
  let a : ^ = b          -- reference to vaariable
  let a = b              -- copy of value
  let a : ^ = &Bar()     -- ERROR: reference to rvalue
  let a : ^ = 5          -- ERROR: reference to rvalue




1.5. copy vs. move

  Value variables are normally copied when assigned and moved when
  in tail position.

  For the copying the compiler generates copy and move code for each
  (complex) type.  Primitive types (like int, char, bool, byte, float,
  or double) are copied with system primitives (e.g. register or
  memory slot assignment).

  The goal of the move methods is to move all values from one place to
  another, and leave the source instance in a state that at
  deallocation/deinitialization doesn't destroy state now used by the
  target instance).  Moving only makes a difference for reference or
  shared objects; for complex types consisting of primitive types only
  the move methods will typically be the same as the copy methods.

  Copy function calls are generated as follows:

  For an expression a = b

      - a and b are the same base type: simply copy register/memory b
        into a

      - a and b are of different base type: ERROR

      - a and/or b are references to the same base type: simply copy
        the base value of b with appropriate de-referencing into a

      - a and b are the same record type: call the concrete copy
        operator copy(a:^Foo, b:^Foo) (which sets a in place)

      - a and b are different record types: ERROR

      - a and/or b are references to the same record types: call the
        concrete copy operator copy(a:^Foo, b:^Foo) with appropriate
        de-referencing

!!    - a and b are of the Any type: call the generic function copy(a
!!      @, b @), assign the ptr result
!!
!!    - a and/or b are references to the same interface or any type:
!!      call the generic function copy(a @, b @), assign the ptr
!!      result


  Move function calls are generated as follows:

  For an expression a <- b:

      - a and b are the same base type: simply copy register/memory b
        into a

      - a and b are of different base type: Error

      - a and/or b are references to the same base type: simply copy
        the base value of b with appropriate de-referencing into a

      - a and b are the same record type call the concrete move
        operator .Foo.move(a, b) (which sets a in place)

      - a and b are different record types: ERROR

      - a and b are references to the same record types: assign the
        ptr of b to a [resetting of a is not necessary, since a move
        source is always in tail position; and there won't be a
        finalizer for a in the context].

      - a or b are references to the same record types: call the
        concrete move operator .Foo.move(a, b) with appropriate
        de-referencing

!!    - a and b are interfaces or any types: assign the ptr of b to a
!!
!!    - a and/or b are references to interface or any types: assign
!!      the ptr of b to a


1.6 Assignment operators

  The normal assignment operator is `=`:

    a = b
    let x = y

  The compiler will automatically decide whether the right hand side
  is copied or moved.


1.7 Creation details

  Instances of primitive and complex types are normally allocated on
  the stack.  The compiler will reserve enough space on the stack for
  a given type.  When an instance is created copied or moved the
  compiler will generate calls to the appropriate creation functions.

  With a type like

    def record Foo (name : String = "hello world", age : Int = 42)

  the following usage

    let a = Foo()

  the compiler will generate code like

    let a : Foo = uninitialized
    init(a)

  When parameters are passed:

    let a : Foo(42, "n.n.")

  the compiler creates:

    let a : Foo = uninitialized
    init(a, 42, "n.n.")

  With a usage like

    let b = Foo()
    ...
    let a = b

  the compiler will generate

    let b : Foo = uninitialized
    init(b)
    ...
    let a : Foo = uninitialized
    init-copy(a, b)  or: init-move(a, b)

  `a` and `b` are technically uninitialized before the matching `init`
  calls (something the user normally can't do).


1.8. De-initialization

  The compiler automatically creates code for deinitializing value
  based (complex) types when instances go out of scope.

  With a record like

    def record Foo (name : String = "hello world")

  the example

    {
      let a = Foo()
      ...
    }

  will generate

    {
      let a : Foo = uninitialized
      init(a)
      ...
      deinit(a)
    }

! If the type of a local variable is an interface or Any a
! `deinitialize()` call is issued.  So with
!
!   {
!     let a = get-something()   -- returns Any
!     ...
!   }
!
!
!   {
!     let a = get-something()
!     ...
!     deinitialize(a)
!   }

  `deinit` and `deinitialize` calls are issued unless instances moved
  away.

  After a `deinit` call the passed instance is not initialized
  anymore.



1.9 Allocating on the heap

  Types can be allocated explicitly on the heap using the allocate()
  call.  It request enough memory to host the memory for a type.  The
  result is always a pointer to the heap:

    let a : ^Foo = allocate(Type<Foo>)

  The allocated memory is uninitialized.  The memory isn't freed
  automatically, for this the deallocate() function has to be called:

    deallocate(a)

  After a call to deallocate() the variable isn't initialized anymore.


1.10 Automatic heap allocation

  For .lang.Any variables the value is automatically boxed,
  i.e. allocated on the heap and automatically deallocated, when the
  variable goes out of scope.  The compiler will generate automatic
  boxing and unboxing code where necessary.

  ...


1.11 Union types

  (Int | String)                -- like C union, value based, initialized to first type in variant

  ...


2.0 Cast

    a = b as Int

  For base types (Int, Bool, Float) this is handled automatically by
  the compiler; for complex types the user can hook into the cast
  process (and allow even "impossible" casts), by implementing the
  `value()` method:

    def value(self @ ^Foo, as-type : Type<'U>) -> ^'U {
      self.value as 'U
    }

  The cast operator is tried when a is assigned to a variable of
  different not immediately allowed type (co- or contra-variant
  depending on context):

    let si = Foo(42)
    let a : Int = si                -- let a : Int = value(si, Type<Int>)
    let a = si as Int               -- let a : Int = value(si, Type<Int>)
    let a = si as Float             -- let a : Int = value(si, Type<Float>)

    def foo(x : Int) ...
    foo(si)                         -- foo(value(si, Type<Int>))


3.0 Operators

  All operators are translated into function calls:

    a = b       =>    set!(a, b)

    a == b      =>    equal?(a, b)
    a <> b      =>    not(equal?(a, b))
    a > b       =>    greater?(a, b)
    a >= b      =>    greater-equal?(a, b)
    a < b       =>    less?(a, b)
    a <= b      =>    less-equal?(a, b)
    a <=> b     =>    compare(a, b)

    a + b       =>    add(a, b)
    a - b       =>    subtract(a, b)
    a * b       =>    multiply(a, b)
    a / b       =>    divide(a, b)
    a ** b      =>    power(a, b)

    a mod b     =>    modulo(a, b)
    a OR b      =>    bitwise-or(a, b)
    a XOR b     =>    bitwise-xor(a, b)
    a AND b     =>    bitwise-and(a, b)
    a or b      =>    logical-or(a, b)
    a and b     =>    logical-and(a, b)
    a << b      =>    shift-left(a, b)
    a >> b      =>    shift-right(a, b)

    a ++ b      =>    concat(a, b)

    a += b      =>    a = add(a, b)
    a -= b      =>    a = subtract(a, b)
    a *= b      =>    a = multiply(a, b)
    a /= b      =>    a = divide(a, b)
    a **= b     =>    a = power(a, b)
    a ++= b     =>    a = concat(a, b)
    a OR= b     =>    a = bitwise-or(a, b)
    a AND= b    =>    a = bitwise-and(a, b)
    a XOR= b    =>    a = bitwise-xor(a, b)
    a or= b     =>    a = logical-or(a, b)
    a and= b    =>    a = logical-and(a, b)

    not a       =>    not(a)
    - a         =>    negate(a)

    a .. b      =>    range(a, b)
    a .. b by c =>    range(a, b, c)

    a as X      =>    value(a, Type<X>)     -- if a is a SharedPtr

    a[x]        =>    slice(a, x)
    a[x] = y    =>    slice!(a, x, y)
    a[f..l]     =>    slice*(a, f, l)



4.0 Parameterized functions

    def reduce-left(proc : 'F, initial : 'K, range : 'R) -> 'K
    {
      let t mut = initial
      while (not empty?(range)) {
        t = proc(t, first(range))
        range = subrange(1, size(range))
      }
      t
    }

  and recursive reduce-right

    def reduce-right(proc : 'F, initial : 'K, range : 'R) -> 'K
    {
      let loop(val : 'K, range : 'R) -> 'K
        if (empty?(range))
          val
        else
          loop(proc(val, last(range)), subrange(0, size(range) - 1))

       loop(initial, range)
    }


5.0 types

5.1 Primitive types

  Int, Float, Char, Bool, Keyword, ...


5.2 Record types

    def record Subject (
      title : String
    )
    def record Student (
      name : String = "",
      birthday : Date = make<Date>(16, 5, 1971),
      subjects : Subject[]
    )


    def main()
      let s = Student("Walter", Data(16, 5, 1982), #[Subject("math"), Subject("history")])

      display("Name: ", s.name,
              " age: ", now() - s.birthday,
              " subjects: ", reduce-left(fn(full, sj) { full + sj.title + ", " },
                                         "",
                                         s.subjects),
              \nl)

  Records can't inherit from records.  Record can "inherit" from
  types.


5.3 Parameterized record types

  Record types can be parametrized.  Every variation forms a different
  type.  Casting between different incarnations is only possible when
  the parameter types are from Any<->concrete.

    def record Pair<K, V> (
      key : K,
      value : V
    )

    def record ValueMap<K, V> (
      data : Pair<K, V>[]
    )

  Creating parametrized types used type deduction:

    let p = Pair(42, "hello")        -- equiv.   Pair<Int, String>(42, "hello")


5.4 Types and type inheriting

  Types declare named relationships and capabilities on records and
  other types and can be used to define generic APIs.  Types don't
  have state or a size.  Therefore types can't be instantiated.

    def type Serializable

    def generic write(o @ Serializable) ...

  Types can inherit arbitrarily from types.



5.5 Variant and optional types

    (A | B | C)                 -- Union<A, B, C>
    (A & B & C)                 -- Intersection<A, B, C>

    def alias String? : (String | Nil)


5.6 Enum types

    def enum Color (
      red, yellow, green, blue, black
    )

    def draw(obj, color : Color) ...

    def main() {
      draw(Box(), Color.green)
    }


5.7 Mixin types

    def type BitmaskType<T>

    def enum FileType : UInt32, BitmaskType<FileType> (
      read = 1 << 0,
      write = 1 << 1,
      append = 1 << 2,
      create = 1 << 3,
      exclusive = 1 << 4,
    )


    def bitwise-or(lhs : BitmaskType<T>, rhs : BitmaskType<T>) -> T
      ((lhs as UInt32) OR (rhs as UInt32)) as T


6 Modules

    module xyz ( ... )

    module xyz

  defines the scope of visibility of bindings and their namespace.
  Modules either have a scope or reach until the end of the source
  file.

  Modules can depend on other libraries ("import").

  Bindings inside a module need to be exported ("export").

    export (foo, bar, baz)

  exports three symbols to the enclosing module/library, independent
  of how deep nested modules are.

    export public (foo, bar, baz)

  exports the bindings to all nesting modules and libraries.

    def module io
    {
      import (string)
      export (Port, InPort, OutPort, SeekablePort, RandomAccessPort,
              FilePort)
      include ("io.hr", "file-port.hr")

      def const val = 42
    }

  Accessing symbols in the namespace:

    foo.val

  Or with a scope marker:

    with ns foo {
      val
    }

    with namespace a.b.c {
      def x() ...
    }


6.1 Libraries

    library xyz ( ... )

    library xyz

  declares a component as a standalone piece of reusable software.
  When compiled will be represented as one .dll, .dylib, or .so.  Apps
  and other libraries can depend on a library ("import (xxx)").
  Libraries are build by "include"ing source files; it's possible to
  specify public "interface" (for declarations and macros) and
  implementation files.  Libraries can use other libraries
  ("import").

  Every Library also forms a module.

  When a library is "imported" the import machinery figures out which
  header files are to be read: These are the source files imported via
  "include public".  (The source files imported with "include" and
  "include tests" are only read when building/compiling the library or
  its test runner itself).


  Example:

    in "vehicles.hr":

      library vehicle {
        import lang                        -- depend on lang library

        include public "vehicle.hr"        -- reads real source files, all code
                                           -- imported "public" is useable as
                                           -- interface from outside.
        include private "impl/vehicle.hr"  -- implementation files

        include tests "tests/vehicle.hr"
      }


    in "vehicle.hr":

      export public *

      def type Vehicle
      def record Car : Vehicle { ... }
      def record Truck : Vehicle { ... }

      def generic serial-number(v @ 'T) -> String
          where T isa Vehicle ...

      def generic owner(v @ 'T) -> String
          where T isa Vehicle ...
      def generic owner!(v @ 'T, o : String) -> 'T ...
      def generic tax(v @ 'T) -> String
          where T isa Vehicle ...

      def generic capacity(v @ 'T) -> Int
          where T isa Truck ...


    in "impl/vehicle.hr":

      def serial-number(v @ Car) -> String
          v.props["serial-number"] as String

      def serial-number(v @ Truck) -> String
          v.props["serial-number"] as String

      def capacity(v @ Truck) -> Int
          v.capacity


   in "tests/vehicle.hr":

     import (lang, tests)

     def test ("car can be sold", "vehicle, setter") {
       let iut = Car()
       iut.owner!("Carl Higgins")

       check(iut.owner() == "Carl Higgins")

       iut.owner!("Thomas Müller")
       check(iut.owner() == "Carl Higgins")
     }


6.3  Applications

    application xyz

  declares an application, i.e. a standalone executable program.  The
  name ("xyz") opens a namespace (like for the module or library
  construction).  It might be used by the compiler for naming the
  resulting executable.  Additional parameters could be given as keyed
  arguments; which arguments are used depends on the compiler,
  platforms, and target format.

    application b99 (
      name: "beer99",
      bundled?: false,            -- use on Mac to make a bundled app
      icon: "../resources/icon.?"
    )

  All of this is optional and might be ignored by the compiler or
  overwritten by compiler options.  The 'application' keyword is
  mainly the marker for the compiler that it is should compile and
  link an executable.


6.4 export, importing

    def pub foo() ...
    def pub const length = 42

or:

    export (foo, length)


7. Functions

  Standalone function:

    def foo(a : Int, b : String, c ...) -> Bool
      body

  Type overload with function selected at compile time by best type
  match:

    def make-sound(a : Animal)     [1]
    def make-sound(a : Mamal)      [2]
    def make-sound(a : Dog)        [3]
    def make-sound(a : Fish)       [4]


    make-sound(Dog())      => variant [3] is called
    make-sound(Spider())   => variant [1] is called
    make-sound(Cat())      => variant [2] is called
    make-sound(Shark())    => variant [4] is called

  Generic method (selected at runtime).  Matching parameters are
  notated with the @ separator (instead of the :).

    def generic draw(a @ GfxObject)

    def method draw(a @ Square)
    def method draw(a @ Line)

  When multiple parameters match it's multiple dispatch:

    def generic connect(inp @ Port, outp @ Port)

    def method connect(inp @ AudioPort, outp @ AudioPort)
    def method connect(inp @ MidiPort, outp @ AudioPort)
    def method connect(inp @ AudioPort, outp @ MidiPort)


  Typical getter & setter method for OOP style:

    def generic foo(self @ ^MyObject) -> T
    def generic foo!(self mut @ ^MyObject, val : T) -> ^MyObject

  Keyed (named) parameters:

    def foo(name -> nm : string = "hello", age -> y : Int) ...
    def foo(name -> nm mut : ^&Int = "N.N.") ...

    ... and at the call site:

    foo(name: "world", age: 92)

  Keyed arguments can't be combined with generic functions.

　Signature definition of functions in headers:

    def foo(a, b) ...
    def foo(a, b) -> Int ...
    def generic foo(a @ Bar) ...


7.1 Anonymous functions:

    fn(a, b) -> C expr

  Type is:

    Fn(A, B) -> C



8.0 Expressions

8.1 Function calls:

    foo(a, b, c)
    foo(a, bar(mar(42), gaz()))

8.2 if/else

    if (foo())
      expr
    else if (bar())
      expr
    else
      expr

8.3 select

    select (foo())
      | v1 -> expr
      | v2, v3, v4 -> expr
      | else -> expr

8.4 loops

    while (condition)
      expr

    while (condition)
      expr
    else
      expr

    for (v : type in range-expr)
      expr

    for (v : type in range-expr)
      expr
    else
      expr

  with range-expr: something which is of type Slicable, e.g.

     #[1, 2, 3]
     0..42


8.5 Type match

    match (foo())
      | v1 : Type -> expr
      | v2, v3, v4 : Type2 -> expr
      | else : Any -> expr


  Example
    def fibonacci(num : Int) -> Int
      if (num <= 1)
         1
      else
         fibonacci(num - 1) + fibonacci(num - 2)


    def main(args ... : String[])
      match (to-int(args[1]))
        | num : Int -> fibonacci(to-int(num))
        | _ : Error -> {
                         display("requires number input", \nl)
                         0
                       }

8.6 Multiple return values and auto-unpack

  Unpack of slices, containers:

    let a, b ... = e     =>  {
                               let tmp = e
                               a = slice(tmp, 0)
                               b = slice-rest(tmp, 1) }
    a, b ... = e         =>  {
                               let tmp = e
                               a = slice(tmp, 0)
                               b = slice-rest(tmp, 1)
                             }

  Unpack of records:

    let record Foo (
      a : A, b : B, c : C
    )
    let x, y, z = Foo()  =>  {
                               let tmp = Foo()
                               x = tmp.a
                               y = tmp.b
                               z = tmp.c
                             }



9. Macros:

    def macro nm
      | « nm1 » -> « ... »
      | « nm2 » -> « ... »

    « »  can be replaced with ?( )?

  Each pattern nm1, nm2, ... must contain the macro-name in the right
  position.  Macro forms can be:

    def <macroname> ...
    <macroname> (...)


  Parse patterns:

    ?xxx:<parameter-type>

  Possible patterns:

    expr
    name
    op | operator

    type
       Matches '<type>' and fails if no such token stream is found.

    typespec
       Matches ': <type>' and fails if no spec is found.  The macro
       variable contains the leading ':'.

       parts:
         spec   '<type>'

    typespec*
       Like typespec, but also succeeds and returns an empty
       replacement stream when no type is found.

    typelist
       Matches a typespec list ': <type> {, <type}`.  Fails if no type
       is found.

       parts:
         specs  '<type> {, <type>}'

    typelist*
       Like typelist, but also succeeds and returns an empty replacement
       stream when no typelist is found.

    param
       Matches a typical parameter spec:

         <key> -> <name> [ : <type> ] [ = <default-expr> ]
         <name> [ : <type> ]
         <name> [ @ <type> ]
         <...> [ : <type> ]

       parts:
         key    '<key>' (or ø)
         name   '<name>'
         type   '<type>' (or ø)
         init   '<expr>' (or ø)

    paramlist
       Matches a (possible empty) list of comma separated parameter
       specifications.

    slot
       Matches a slot specification: '<name> [ : <type> ] [ = <init-expr> ]'

       parts:
         name   '<name>'
         type   '<type>' (or ø)
         init   '<expr>' (or ø)

    slotlist
      Matches a (possible empty) list of comma separated slot
      specifications.


    docstr*
       Matches a documentation string ('~...~').  This succeeds also
       when no documentation string is found, returns an empty
       replacement stream.

  Parse variables

    xxx ## abc  concat two symbol into a new
    xxx ## "42" concat non symbol chars to symbol into a new
    abc ## ":"  concat to produce a keyarg
    ?abc        replace with the parsed variable 'abc'
    ?{abc.def}  access part 'def' from parsed variable 'abc'.  For the
                parts see the patterns.
    ?"abc"      replace with the parsed variable 'abc' as string
    #?abc       replace with the parsed variable 'abc' as keyword
    #?{abc.def} replace with part 'def' from parsed variable 'abc' as keyword

    ?( )?       instead of « »


10. Encoding in C namespace

  Function overloading requires encoding parameter types into the C
  function name.  LLVM IR requires "simple" names, so we need one name
  for each function variant.

  We already use the QN mangling to encode special characters.  E.g.

    encode->string!

  becomes

    __QNencode/2d/3estring/21

  So our pattern is:

  For functions:

    1. Start with __Q
    2. Encode function type: M = generic, F = normal function
    2. add a N, then the namespaces with each step prefixed with the length
    3. add the symbol, prefixed with the length
    4. add a S, encode return type
    5. encode types of parameters

  encode one type

  Use shortcuts for builtin types:

    Bool         b
    Int8         c
    UInt8        o
    Int16        s
    UInt16       w
    Int32        i
    UInt32       u
    Int64        I
    UInt64       U
    Float32      f
    Float64      F
    Float128     D
    String       S
    Unspecified  v
    Eof          e
    Nil          n

    add a 'r' for reference to the type
    add a 'R' for ref-counted type
    add a 'A' for array

    user       _[TREIU]N{ns}(sym)generics?

  Parameters can use a namespace shortcut: if parameter types are in
  the same namespace as the function's use a Ns for the {Ns} part
  simply.

  If the type is generic the generic type params are added recursively
  enclosed in a P...x group.

  Intersection and Union types are ended with x

  Example:

    .io.foo(: .io.Port<Octet>, : Float32[]) -> BoolOrEof

    _QFN2io3fooS_Ubex_TNs4PortPoxAf


  For global variables

    1. Start with __Q
       1. var type: V = variable
    2. add the namespaces and symbol each prefixed with the length as digits

  For types:

    1. Start with __Q
       1. type kind: T = type, R = record, E = enum, I = intersection, U = union


11. Naming conventions:

    foo()         value getter or non-modifying function
    foo!()        value setter

    Foo?          alias convention for (Foo | Nil)
    ^Foo?         rewritten by compiler as (^Foo | Nil)
    &Foo?         rewritten by compiler as (&Foo | Nil)

    bar(o : Foo)
    bar*(o @ Foo) generic versions of concrete functions are marked with a *
