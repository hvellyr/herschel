\input texinfo @c -*-texinfo-*-
@c %**start of header
@setfilename heather.info
@settitle heather -- an experimental programming language
@finalout
@setchapternewpage odd
@c %**end of header

@c This file is processed by Arc! Placeholders are surrounded by &
@c (amp) and not by @ (at) as normally, since Texinfo uses @ as markup maker!
@set VERSION 0.0.1
@set COPYRIGHT 2002, 2003, 2009, 2010 Gregor C.@ Klinke


@titlepage
@title heather
@subtitle an experimental programming language
@subtitle for heather vr. @value{VERSION}
@author by Gregor C.@ Klinke

@page
@vskip 0pt plus 1filll
Copyright (C) @value{COPYRIGHT}. All rights reserved.

Redistribution and use in source (@acronym{GNU} texinfo) and `compiled'
forms (@acronym{SGML}, @acronym{HTML}, @acronym{PDF}, PostScript,
@acronym{RTF} and so forth) with or without modification, are permitted
provided that the following conditions are met:

@enumerate
@item Redistributions of source code (@acronym{GNU} texinfo)
must retain the above copyright notice, this list of conditions and the
following disclaimer as the first lines of this file unmodified.

@item Redistributions in compiled form (transformed to other
markup, converted to @acronym{PDF}, PostScript, @acronym{RTF} and other
formats) must reproduce the above copyright notice, this list of
conditions and the following disclaimer in the documentation and/or
other materials provided with the distribution.
@end enumerate

THIS DOCUMENTATION IS PROVIDED BY THE AUTHORS ``AS IS'' AND ANY EXPRESS
OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED.  IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY DIRECT,
INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
ANY WAY OUT OF THE USE OF THIS DOCUMENTATION, EVEN IF ADVISED OF THE
POSSIBILITY OF SUCH DAMAGE.
@end titlepage

@contents

@c All the nodes can be updated using the EMACS command
@c texinfo-every-node-update, which is normally bound to C-c C-u C-e.
@node Top, Introduction, (dir), (dir)

@ifinfo
This manual documents @emph{heather}, an experimental programming
language.  It refers to version @value{VERSION}.
@end ifinfo

@c All the menus can be updated with the EMACS command
@c texinfo-all-menus-update, which is normally bound to C-c C-u C-a.

@menu
* Introduction::                Introduction
* Lexical elements::            Lexical elements
* Functions::                   Functions
* Types::                       Types
* Bindings::                    Bindings
* Expressions::                 Expressions
* Program control::             Program control
* Program structure::           Program structure
* Macros::                      Macros
* Appendix::                    Appendix
* Function Index::              Index of functions
* Concept Index::               Index of concepts
@end menu

@ifinfo
Copyright (C) @value{COPYRIGHT}. All rights reserved.

Redistribution and use in source (@acronym{GNU} texinfo) and `compiled'
forms (@acronym{SGML}, @acronym{HTML}, @acronym{PDF}, PostScript,
@acronym{RTF} and so forth) with or without modification, are permitted
provided that the following conditions are met:

@enumerate
@item Redistributions of source code (@acronym{GNU} texinfo)
must retain the above copyright notice, this list of conditions and the
following disclaimer as the first lines of this file unmodified.

@item Redistributions in compiled form (transformed to other
markup, converted to @acronym{PDF}, PostScript, @acronym{RTF} and other
formats) must reproduce the above copyright notice, this list of
conditions and the following disclaimer in the documentation and/or
other materials provided with the distribution.
@end enumerate

THIS DOCUMENTATION IS PROVIDED BY THE AUTHORS ``AS IS'' AND ANY EXPRESS
OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED.  IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY DIRECT,
INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
ANY WAY OUT OF THE USE OF THIS DOCUMENTATION, EVEN IF ADVISED OF THE
POSSIBILITY OF SUCH DAMAGE.
@end ifinfo


@c ====================================================================
@node Introduction, Lexical elements, Top, Top
@chapter Introduction

This is the reference specification for the @dfn{Heather} programming
language.

Heather is an general-purpose multiparadigm programming language.  It is
strongly typed, offering type inference, and parametric polymorphism
(``generics'').  It is consequently object oriented (everything is a
object, even functions are instances of the type @code{Callable}), while
its consequent multiple dispatch approach gives it a strong functional
touch.  The object model is class-oriented, supporting multiple
inheritance just as a separation of types (``protocols'',
``interfaces'') and classes.

The grammar is regular, small, and context free.  In particular it can
be parsed without symbol tables, and does not required a special
preprocessor since it offers powerful hygienic macros as part of the
language.

It is designed for a conventional compile-link development model, though
this is not required by the specification.


@c --------------------------------------------------------------------
@section Used notation in this specification

When syntax is given formally it is notated using Extended Backus-Naur
Form (EBNF):

@cartouche
@verbatim
production  := PRODUCTION-NAME `:=' expression
expression  := alternative { `|' alternative }
alternative := term { term }
term        := PRODUCTION-NAME | TOKEN [ `...' TOKEN ] | group | option
               | repetition
group       := `(' expression `)'
option      := `[' expression `]'
repetition  := `{' expression `}'
@end verbatim
@end cartouche

Productions are expressions constructed from terms and the following
operators, in increasing precedence:

@table @asis
@item |
alternation
@item ()
grouping
@item []
option (0 or 1 times)
@item @{@}
repetition (0 to n times)
@end table

Capital only production names are used to identify lexical tokens.
Non-terminals are in lowercase.  Lexical symbols are enclosed in single
quotes.

The form @code{'a' ... 'b'} represents the set of characters from `a'
through `b' as alternatives.

Syntax productions are indicated by a frame around the display (in the
printed manual).


@c --------------------------------------------------------------------
@section Source code representation

Heather code is written in source files, normally taking the suffix of
@file{.hea}.  These files can take any number of class, type, and
function definitions.  Technically the language does not impose and
constraint on the way a source file is to be named or where it is to be
located; there's especially no coupling of namespace or folder
structure.

Source files are expected to be encoded in UTF-8 encoding.  Note that
the text is taken as is, i.e. no normalization is expected or applied.
Note furthermore that identifiers are restricted to a less narrower set
of characters.



@c ====================================================================
@node Lexical elements, Functions, Introduction, Top
@chapter Lexical elements

@c ....................................................................
@section Comments

Comments start with the character sequence @code{--} and continue
through the next newline.  There are no block comments.

@c ....................................................................
@section Identifiers

Identifiers and symbols can contain much more special characters than in
most other programming languages.  Adding whitespace between token is
therefore indispensable.

Identifier in Heather are case sensitive.

@cartouche
@smallformat
@verbatim
identifier  := first-char { other-char }
first-char  := letter | first-other
other-char  := letter | digit | other
letter      := `a' ... `z' | `A' ... `Z'
digit       := `0' ... `9'
first-other := `_' | `*' | `+' | `%' | `?' | `!' | `/'
other       := `-' | first-other
@end verbatim
@end smallformat
@end cartouche

Note especially the special characters `+', `+', `-', and `/' as part of
names.

@example
*stdout*
%some-constant%
-a-string-
_a_string_
_a/string_
@end example

Note that identifiers are not allowed to contain arbitrary unicode
characters even though the source code itself is encoded in UTF-8.


@c ....................................................................
@section Reserved identifiers

The following identifiers are reserved and have a special meaning:

@verbatim
alias      fluid       mod             select
and        for         namespace       slot
by         if          or              slot!
class      in          otherwise       then
const      let         public          type
def        macro       private         until
else       meth        protected       while
@end verbatim


@c ....................................................................
@section Operator identifiers

The following identifiers are reserved and handled as operators:

@verbatim
%    &    *    **   +    -    ->   ..   ...  /
<    <<   <=   <=>  <>   ==   >    >=   >>   ^
and  by   in   mod  or   |
@end verbatim

Note that operators are really identifiers @emph{not} delimiters.


@c ....................................................................
@section Delimiters

@c todo 

@verbatim
"    '    .    ,    ;    #    @    (    )    [    ]    {    }
@end verbatim


@c ....................................................................
@section Boolean constants

@findex #true
@findex #t
@findex #false
@findex #f
@findex Boolean
The boolean constants @dfn{true} and @dfn{false} are logically realized by
singleton instances of the class @code{Boolean}.

@example
#true #t #false #f
@end example

There's no difference between @code{#t} and @code{#true} resp.@
@code{#f} and @code{#false}.

@c ....................................................................
@section Other constants

@findex #unspecified
@findex Unspecified
@findex #eof
@findex Eof
@findex #nil
@findex Nil
The constant @code{#nil} denotes the zero value of reference types.  It
is logically realized by the singleton instance of the class @code{Nil}.

Similar to @code{#nil} the constant @code{#eof} denotes the end of
sequence of values (it name derives from ``end of file'', but it is
equally used for ``end of list'', or ``end of iterator'').  It is
logically realized by the singleton instance of the class @code{Eof}.

There's a special constant @code{#unspecified} which is a singleton
instance of the type @code{Unspecified}.  This value can not be compared
or transformed.  Its sole purpose is to be returned from expressions or
functions where no reasonable return value exists.


@c ....................................................................
@section Chars

@c todo 

@example
\a
\space
\u41h
\nl
@end example


@c ....................................................................
@section String

@c todo 

@example
"abc"
"hello world"
"Usage: cmd OPTIONS\nl;"
"a string"
"a \nl;string"
"a \tab;string"
"a \\string"
"a \"string"
"a \A;string"
"a \u41h;string"
@end example


@c ....................................................................
@section Keywords

Keywords denote a global unique identity.  This holds true even if
keywords are imported from a dynamic linked object (e.g. Dll) which has
been compiled and linked on a different machine.

@example
'symbol
'hello-world
@end example

Keywords are first class objects and can be created at runtime
(@code{to-keyword()}); they are assumed however to show a much better
performance when comparing for identity.


@c ....................................................................
@section Arrays

@c todo 

@example
a constant array: #[1, 2, 3, 4, 5]
@end example


@c ....................................................................
@section Vector

@c todo 

@example
#(1, 2, 3)
@end example


@c ....................................................................
@section Dictionary

@c todo 

@example
#("abc" -> #[1, 2, 3],
  "def" -> 'symbol,            -- symbol
  "xyz" -> \a,                 -- char
  "mmm" -> \u41h,              -- char
  "ch1" -> \space              -- char
)
@end example


@c ....................................................................
@section Numbers

@c todo 

Notation:
@example
1234                           -- decimal
100h                           -- hexadecimal
100y                           -- binary
100o                           -- octal
@end example

Type notation:
@example
1234                           -- precise integer
123.4                          -- precise real
12/34                          -- precise rational
12 + 34i                       -- precise complex
12.3+34j                       -- precise complex
1.23e-45                       -- precise integer (exp. not.)

123t                           -- (approx) octet
123s                           -- (approx) signed short
123us                          -- (approx) unsigned short
123w                           -- (approx) word
123uw                          -- (approx) unsigned word
123l                           -- (approx) long
123ul                          -- (approx) unsigned long
123.4f                         -- (approx) ieee754 float
123.4d                         -- (approx) ieee754 double
123.4ld                        -- (approx) ieee754 long double
@end example

Exact and approximate numbers.

Exact numbers: Number <- Complex <- Real <- Rational <- Integer

@ftable @code
@item Number
@item ComplexNumber
@item Real
@item Rational
A rational number, e.g. @code{1/3}, or @code{-1/17}.
@item Integer
@end ftable

Approximate numbers:

@ftable @code
@item Octet
8bit unsigned integer
@item Short
16bit signed integer
@item UShort
16bit unsigned integer
@item Word
32bit signed integer
@item UWord
32bit unsigned integer
@item Long
64bit signed integer
@item ULong
64bit unsigned integer
@item Float
32bit ieee754 float
@item Double
64bit ieee754 double
@item LongDouble
128bit ieee754 long double
@end ftable


@smallexample
   +------+
   |Number|
   +------+
      ^  ^
      |  \--------------\
      |                 |
   +-----+          +-----------+
   |Exact|          |Approximate|<--------------\
   +-----+          +-----------+<------\    |  |
      ^                ^  ^^  ^      |  |    |  |
      |                |  ||  |      |  |    |  |
   +-------+       +-----+||+-----+  |+----+ |+----+
   |Complex|       |Octet||||Short|  ||Word| ||Long|
   +-------+       +-----+||+-----+  |+----+ |+----+
      ^                   ||+------+ |+-----+|+-----+
      |                   |\|UShort| \|UWord|\|ULong|
   +----+                 | +------+  +-----+ +-----+
   |Real|                 |
   +----+                 | +-----+
      ^                   |-|Float|
      |                   | +-----+
   +--------+             | +------+
   |Rational|             \-|Double|
   +--------+               +------+
      ^
      |
   +-------+
   |Integer|
   +-------+

   +-------+     +---------+
   |Ordered|     |Unordered|
   +-------+     +---------+

   +-------------+  +-------------+
   |Bounded-Above|  |Bounded-Below|
   +-------------+  +-------------+
          ^              ^
          |              |
          \-------+------/
                  |
              +-------+
              |Bounded|
              +-------+

   +---------------+  +---------------+
   |Unbounded-Above|  |Unbounded-Below|
   +---------------+  +---------------+
          ^                 ^
          |                 |
          \----------+------/
                     |
                +---------+
                |Unbounded|
                +---------+
@end smallexample


@c ====================================================================
@node Functions, Types, Lexical elements, Top
@chapter Functions

Besides 'normal' standalone functions Heather supports so called generic
functions which are specialized on one or more parameters to certain
types.  These generic functions make up Heather's Object Oriented
system.

@menu
* Standalone Functions::        Standalone Functions
* Generic Functions::           Generic Functions
* Positional Parameters::       Positional Parameters
* Keyword parameters::          Keyword parameters
* Optional parameters::         Optional parameters
* Mixed parameters::            Mixed parameters
@end menu


@c --------------------------------------------------------------------
@node Standalone Functions, Generic Functions, Functions, Functions
@section Standalone Functions

Standalone functions are not bound to any particular type.  They are
resolved by their name only.  There's nothing like type-overwriting,
etc.

@cindex functions, defining
@findex def [function]
@findex let [function]
@deffn Special def @var{name} ([@var{parameters}]) @
       [@code{:} @var{return-type}] @
       @var{function-body}
@deffnx Special let @var{name} ([@var{parameters}]) @
        [@code{:} @var{return-type}] @
        @var{function-body}

Defines a function with @var{parameters} and the body
@var{function-body} bound to @var{name}.  The @var{function-body} is
expected to be a @emph{single} expression, i.e. for a multi expression
body it must be written as a block.  As an exception function bodies on
top-level, i.e. where functions are defined with the @code{def} keyword,
are delimited by the next @code{def} keyword or the file end.

Functions are always defined in recursive mode, i.e. a function
@var{name} can ``see'' (i.e. call) itself recursively.

For the way to define the @var{parameters} see below.

@example
def ack(x : Int, y : Int) : Int
  if (x == 0)
    y + 1
  else if (y == 0)
    ack(x - 1, 1)
  else
    ack(x - 1, ack(x, y - 1))
@end example
@end deffn


@c --------------------------------------------------------------------
@node Generic Functions, Positional Parameters, Standalone Functions, Functions
@section Generic Functions

Generic functions in contrast are specialized by one or more
parameters to certain types.  They are declared using the @code{meth}
modifier.

@cindex generic functions, defining
@findex def meth
@findex meth
@deffn Special def @code{meth} @var{name} ([@var{parameters}]) @
       [@code{:} @var{return-type}] ...
@deffnx Special def @code{meth} @var{name} ([@var{parameters}]) @
       [@code{:} @var{return-type}] @
       @var{function-body}

Defines a generic function named @var{name}.  The first form (with the
leftout body) defines an abstract generic function signature without
specialization.  The second form (incl. the body) defines the generic
function and provides a first specialization.

@findex @@ (specialization marker)
Parameters are specialized by adding the `@@' to their type
declaration.  Only positional parameters can be specialized.  It is an
error if a function is declared a generic using the @code{meth} keyword
but no parameter is specialzed.

Generic functions must be defined at least once.  Multiple generic
definitions must be compatible in return type and the types of
non-specialized parameters.  A generic function specialization (a
@dfn{method}) must not be defined before its generic method definition.

It's possible to define an empty, i.e. abstract, generic function:

@example
def meth compare(one : @@ OneType, two : @@ TwoType) : Bool ...
@end example

Note the ellipsis @code{...} at the end of the line.

To put it another way: defining a generic function with a body
implementation is like defining an abstract generic function with
certain parameters specialized to @code{Any} @emph{and} adding a
default implementation:

@example
def meth add-x(self : @@ Any, value : @@ Any) ...

def add-x(self : @@ XMap, value : @@ Int)
  self.insert(value, -1)
@end example

Further specialization don't have to state the @code{meth} keyword
anymore, they must mark the specialized parameters however (using the @@
marker).

When applying (calling) a generic function the method is looked up by
name (like a normal standalone function) and matching the parameter
types to specialized parameters.  Resolve order is always from first to
last parameter.  For each parameter the most specific type matches.
@end deffn


@deffn Special next-method ()
Inside generic functions @code{next-method} calls the next overwritten
method with exactly the same parameters are the current active function.
This resembles somewhat a call to @code{super} in other programming
languages.

@example
def meth before-open(self : @@ Document) : Bool
  if (next-method()) @{
    self.fill-in-dsp-tables
    #t
  @}
  else
    #f
@end example

@end deffn


@c --------------------------------------------------------------------
@node Positional Parameters, Keyword parameters, Generic Functions, Functions
@section Positional Parameters

Positional parameters:

@example
def f(a, b, c) @emph{body}
@end example

are used as:

@example
f(1, 2, 3)
@end example


@c --------------------------------------------------------------------
@node Keyword parameters, Optional parameters, Positional Parameters, Functions
@section Keyword parameters

Heather function can use named arguments with @dfn{keyword parameters}.
These are declared by adding a default value to the parameters name:

@example
def f(a = 5, b = "hello world", c = @{ let x = 5
                                      x * x @})
  @emph{body}
@end example

The default value can be any valid expression, even complete block (as
to be seen for the parameter @code{c} in the example above.  This can be
used like in the following examples:

@example
f(a: 11, b: "N.N.", c: 255)
@result{} a -> 11
   b -> "N.N."
   c -> 255

f()
@result{} a -> 5
   b -> "hello world"
   c -> 25

f(c: 7, a: 0)
@result{} a -> 0
   b -> "hello world"
   c -> 7
@end example

By default the keyword and the parameter name are identical (like @code{a} and
@code{a:} in the examples above).  It is possible to specify a
particular keyword name in the declaration however:

@example
def f(fst: a = 5, snd: b = "hello world", trd: c = @{ let x = 5
                                                    x * x @})
  @emph{body}

f(fst: 127, trd: 8, snd: "/")
@result{} a -> 127
   b -> "/"
   c -> 8
@end example


@c --------------------------------------------------------------------
@node Optional parameters, Mixed parameters, Keyword parameters, Functions
@section Optional parameters

Additionally to positional and keyword parameters it is possible to
define a @dfn{rest parameter} which takes all arguments additionaly to
be found in a function call:

@example
def f(args ...)
@end example

When called it puts all additional parameters, including all keyword
arguments which are not matching, into an immutable array:

@example
f()
@result{} args -> #[]

f(1, 2, 3, 4)
@result{} args -> #[1, 2, 3, 4]

f(#[1, 2, 3, 4])
@result{} args -> #[#[1, 2, 3, 4]]

f(a: 1, b: 2, 3, 4)
@result{} args -> #['a, 1, 'b, 3, 4]
@end example


@c --------------------------------------------------------------------
@node Mixed parameters,  , Optional parameters, Functions
@section Mixture of the parameter types

When using positional, keywords and optional parameters at the same time
in a function declaration, they have to appear in the following order:

@enumerate
@item positional
@item keyword
@item optional
@end enumerate

@example
def f(a, b, c, d = #t, e = 25, f ...)
@end example

The same basic order applies to function calls.  Even if keyword
arguments can be ordered in any way, they always have to follow
positional arguments.

Keyword arguments are always ordered in lexicographical way when listed
in an optional argument:

@example
f(1, 2, 3)
@result{} a -> 1
   b -> 2
   c -> 3
   d -> #t
   e -> 25
   f -> #[]

f(4, 5, 6, e: 127, "hello world", "sic est")
@result{} a -> 4
   b -> 5
   c -> 6
   d -> #t
   e -> 127
   f -> #["hello world", "sic est"]

f(1, 2, 3, z: 1, g: 2, h: 3)
@result{} a -> 1
   b -> 2
   c -> 3
   d -> #t
   e -> 25
   f -> #['g, 2, 'h, 3, 'z, 1]
@end example


@c ====================================================================
@node Types, Bindings, Functions, Top
@chapter Types

Heather's type system is nominative, i.e.@ types are identified by name.
Types can be parameterized, constrained, or being complex sets of types
(union types).  Types are first class, i.e.@ types have a runtime
representation and are objects themselves.

Types are orthogonal to namespaces.  Methods and functions are not
@sc{members} of types; neither is it possible to define sub-classes or
enumerations inside of types.  Methods are specialized @emph{on} types,
they are however not members @emph{of} types.

Types can define a number of supported functions.  These functions must
be implemented as generic function elsewhere.

@cindex multiple inheritance
Heather supports multiple inheritance.  All inherited types must be
compatible in required functions and slot names, neither in public nor
private ones.  If two inherited types have exactly the same slot (they
are identical in name, type and initial value), they share the same
physical allocation space.  If two inherited types have exactly the same
required function is treated to be the same required function.

Cyclic inheritance is not possible.


@menu
* Defining types::              Defining types
* Slots::                       Slots
* Required Functions::          Required Functions
* Finalization::                Finalization
* Array types::                 Array types
* Parameterized types::         Parameterized types
* Constraint types::            Constraint types
* Union types::                 Union types
* Function types::              Function types
@end menu


@c --------------------------------------------------------------------
@node Defining types, Slots, Types, Types
@section Defining types

@cindex classes
@cindex classes, defining
@cindex types
@cindex types, defining

Heather distinguishes between @dfn{type} and @dfn{class}.  Every class
has exactly one type, but not every type is represented by a class.
A union type for example forms a specific type without a class.  Only
classes can be instantiated.

There are three forms for defining types.  The first, @code{def class},
is used for defining a class, i.e. a type which has a defined run-time
representation with a certain memory layout and which is (ultimatively)
intended to be instantiated.  The second, @code{def type}, is used to
define a logical type, which is not supposed to have a run-time
allocation representation.  The third, @code{def alias}, is a shortcut
definition, where a type declaration is bound to a new name.

@cartouche
@smallformat
@verbatim
class-def   := `def' [ visibility ] `class' identifier
               [ `<' type-param { `,' type-aram } `>' ]
               [ `(' init-param { `,' init-param } `)' ] 
               [ `:' inheritance ]
               `{' { slot-def } { protocol-def } `}'
type-param  := parameter
init-param  := parameter
inheritance := type-clause
@end verbatim
@end smallformat
@end cartouche


@c todo generics
@findex def class
@findex class
@deffn Special def @code{class} @var{name} @
       [<@var{types}>] [(@var{params})] [@code{:} @var{inheritance}] @
       @{ [ @var{slots} ] [ @var{protocol} ] @}
Define a class @var{name} with @var{params}.  The class will have
derive from @var{inheritance} and have @var{slots} slots.

If @var{types} is a non empty list of variables the resulting type is
set to be @dfn{parameterized}.  These parameters are @dfn{type
parameters}, which can be used in type declarations on the slot
definitions in @var{slots} and from related method definitions.

With @var{params} the parameters for the default @code{apply} method can
be defined.  See @ref{Positional Parameters} for the syntax details.

@var{Inheritance} is either a single type declaration or a list of comma
separated type declarations.  This gives the full inheritance definition
of the resulting type.  The order of the types gives their specifity.

For @var{slots} it is valid to be empty.

Every class ultimatively inherits from @code{Object}.  This type is
automatically added to the inheritance list when missing.

@var{protocol} gives the list of all functions required by this
type.  See @ref{Required Functions} for details.

@end deffn


@cartouche
@smallformat
@verbatim
type-def    := `def' [ visibility ] `type' identifier
               [ `<' type-param { `,' type-aram } `>' ]
               [ `:' inheritance ]
               `{' { protocol-def } `}'
type-param  := parameter
inheritance := type-clause
@end verbatim
@end smallformat
@end cartouche

@c todo generics
@findex def type
@findex type
@deffn Special def @code{type} @var{name} @
       [<@var{types}>] [@code{:} @var{inheritance}]
       [ [ @var{protocol} ] @} ]
Defines a new type @var{name} which is derived from @var{inheritance}.
@var{inheritance} is either a simple type declarations or a list of type
declarations.

@example
def type RandomAccessStream : (InputStream, OutputStream,
                               RepositionableStream)
@end example

The resulting type is a new type with its own run-time representation
which is different to those of its inherited types -- even in case of
single inheritance.

Other than classes a type does not automatically inherit from
@code{Object}; it is possible to have types without inheritance at all.
Such a type is useful for defining type signatures (aka ``interface''s
in Java) and even mixins:

@example
def type Comparable

def meth compare(one : @@ Comparable, two : @@ Comparable) : Int ...

def meth less?(one : @@ Comparable, two : @@ Comparable) : Bool
  (one <=> two) < 0

def meth equal?(one : @@ Comparable,
                two : @@ Comparable) : Bool
  (one <=> two) == 0

def meth less-equal?(one : @@ Comparable,
                     two : @@ Comparable) : Bool
  (one <=> two) <= 0

def meth greater?(one : @@ Comparable,
                  two : @@ Comparable) : Bool
  (one <=> two) > 0

def meth greater-equal?(one : @@ Comparable,
                        two : @@ Comparable) : Bool
  (one <=> two) >= 0
@end example

Every class or type inheriting from @code{Comparable} automatically gets
the compare operators @code{<}, @code{<=}, @code{>}, etc. and only has
to specialize the method @code{compare} (as implementation of the
operator @code{<=>}).  This method is kept as abstract generic function
but bound to the @code{Comparable} type.

@var{protocol} gives the list of all functions required by this
type.  See @ref{Required Functions} for details.
@end deffn

@cartouche
@smallformat
@verbatim
alias-def   := `def' [ visibility ] `alias' identifier `=' type
@end verbatim
@end smallformat
@end cartouche

@findex def alias
@findex alias
@deffn Special def @code{alias} @var{name} = @var{type}
Defines an alias for @var{type}.  @var{name} and @var{type} afterwards
are totally synonym, i.e. @var{name} is not considered a new type.  The
only purpose of this form is to provide a more readable form for
@var{type}.

@c todo generics
@example
def alias UserTagMap = HashMap<String, UserTag<String, Int> >

def meth add-tags(tags : @@ UserTagMap) ...                     [1]
def meth add-tags(tags : @@ HashMap<String,
                                   UserTag<String, Int> >) ... [2]
@end example

The two method declarations at [1] and [2] are completely identical.

(Alias definitions are comparable to @code{typedef}s in C and C++.)
@end deffn


@c --------------------------------------------------------------------
@node Slots, Required Functions, Defining types, Types
@section Slots

Slots are defined as variables inside the block of a type declaration using
the special @code{slot} define form:

@example
def class Point : Object
@{
  slot x : Int = 0
  slot y : Int = 0
@}
@end example

The assign value is the slot's default value which is used when an instance
of the type is created.

There are no constructors in Heather and they are seldomly needed (since
slots are initialized by default).  If one needs additional
initialization code it is possible to add a init hook to the type using
the @code{on init} directive.

@findex on init
@findex init
@deffn Handler on @code{init} (@var{self}) @var{expr}
The @code{on init} hook is called as part of the instance
initialization.  Directly after instance allocation and binding of
init values to the instance's slots the init hook is called.  As single
argument the instance is passed to @var{self}.

@example
def class ProxyBridge : Object
@{
  on init(self)
  @{
  @}
@}
@end example
@end deffn

By default Heather creates the necessary @code{apply()} implementation
for each type.  It is possible to specify the default parameters in the
class definition:

@example
def class SenseOfLife(x: _x = 6, y: _y = 7) : Object
@{
  slot x : Int = _x
  slot y : Int = _y
@}

-- the followig method is generated by the compiler
def meth apply(self : @@ SenseOfLife,
               x: _x : Int = 6,
               y: _y : Int = 7)
  @emph{body}
@end example

Instances of SenseOfLife can be created now like:

@example
SenseOfLive(x: 6, y: 7)
SenseOfLive(y: 7)
SenseOfLive()
@end example

It is possible of course to use positional parameters in class
definitions:

@example
def class SenseOfLife(_x, _y) : Object
@{
  slot x : Int = _x
  slot y : Int = _y
@}

-- result in
def meth apply(self : @@ SenseOfLife, y : Int, x : Int)
  @emph{body}
@end example

For special constructors you can define and implement your own
@code{apply} methods for your type of course.  Heather will only create
@code{apply} functions if you don't do it yourself.


@c --------------------------------------------------------------------
@node Required Functions, Finalization, Slots, Types
@section Required Functions

A type can define a list of required functions which must be implemented
at least by one specialized method to fulfill the type's protocol.  For
a class it is an error if a function is not implemented.

@example
def type Collection<Elt>
@{
  def meth add(self : @@, item : @@ Any) : self.Type ...
  def meth contains?(self : @@, item : @@ Any) : Bool ...
@}
@end example

Such defined required functions must be defined without body (i.e.@
require the ellipsis on the line end) and are by default defined as
generic functions.  The keyword @code{meth} is optional here.  Function
declared in this way must match be compatible with generic functions of
same name defined in other places (independant whether defined as
standalone or required generic functions).

For required functions specialized parameters which refer to the
enclosing type can be abbreviated with a simple `@@' marker.

Required functions are inherited to subtypes. If a subtype requires the
same function as an inherited type the ``overloaded'' function must be
type-congruent to the overwritten function, i.e.@ its returntype must be
`larger' or equal to the of the overwritten function, etc.

Note that the definition of a type protocol is really the specification
of a list of required functions -- there may exist much more functions
which are specialized on the type.

@c --------------------------------------------------------------------
@node Finalization, Array types, Required Functions, Types
@section Finalization

@cindex finalization
@cindex destructor
@findex on delete
@findex delete
@deffn Handler on @code{delete} (@var{self}) @var{expr}

It is possible to add special finalization code inside the type
declaration using the @code{on delete} directive.  Note that this is not
a real destructor (which is not necessary in Heather), but a kind of
finalization which is only necessary to free (external) resources.

As single argument the instance is passed to @var{self}.

@example
def class ProxyBridge : Object
@{
  on delete(self)
  @{
  @}
@}
@end example
@end deffn

@c --------------------------------------------------------------------
@node Array types, Parameterized types, Finalization, Types
@section Array types

Every type can exist as simple or as @dfn{array type}.  Arrays are
nevertheless first class objects.

@example
let buffer : Char[]        [1]
let tmp : Int[10]          [2]
@end example

[1] defines @code{buffer} as an array of unspecified size.  The initial
value is @emph{not} @code{#nil}, but an empty array of characters.  With
[2] the variable @code{tmp} is initialized to an array of 10 integers.
Note that an array's size is not an integral part of the type, nor is it
a constraint (see below).


@c --------------------------------------------------------------------
@node Parameterized types, Constraint types, Array types, Types
@section Parameterized types

Types can be parameterized.  The parameters are types themselves.  Other
than @code{C++} or @code{D} templates there's only one type instance in
heather however.

@example
def class Pair<One, Two>(_one : One, _two : Two)
@{
  slot one : One = _one
  slot two : Two = _two
@}
@end example

To allocate a new instance of such a class the parameters must
specified:

@example
let p = Pair<Int, Real>(5, 7.0)
@end example

It possible to leave the type parameters out, if the compile can infer
the types (as in the example above):

@example
let p = Pair(5, 7.0)
@end example

Note that it is not possible to create an instance of the type
@code{Pair} (in the example above) without the proper type parameters.
It is possible to define default values of the types parameters however:

@example
def class Pair<One = Any, Two = Any>(_one, _two)
@{
  slot one : One = _one
  slot two : Two = _two
@}
@end example

Then the following allocation is possible:

@example
let p = Pair<>(5, 7.0)
@end example

Parameterized types can be used to specialize methods:

@example
def meth do-y(self : @@ Pair<Int, Int>) ...   [1]
def meth do-y(self : @@ Pair<>) ...           [2]
def meth do-y(self : @@ Pair) ...             [3]
@end example

The case [1] will match for any Int-Int-Pair only, the case [2] matches
for any Any-Any-Pair.

Case [3] is a special case.  Effectively the case [3] implementation
behaves like [2] (i.e. a Pair(Any, Any)) during runtime.  But during
compilation the calling code of such a method will treat it as if it
would have been called using proper type parameters.  Take the following
example:

@example
def meth distance(self : @@ Pair) ...

def x(offset : Int)
  let p : Pair<Int, Int>
  ...
  distance(p) + offset
@end example

In the implementation of @code{x()} the compiler does not know about the
return type of @code{distance()} and cannot optimize or check whether
the @code{+} operator is used correctly -- since the method definition
of @code{distance} is incomplete.  Here a special notation on the method
definition is used:

@example
def meth distance(value : @@ Pair) : value.Type.One ...

def x(offset : Int) : Int
  let p : Pair<Int, Int>
  ...
  distance(p) + offset
@end example

Now the definition of @code{distance()} tells the compiler that the
returntype of the method will be the same as the type of the @code{One}
type parameter of the type of the method's @code{value} parameter.  In
the body of @code{x()} @code{distance()} is called with a value of type
@code{Pair<Int, Int>}, therefore the compiler can infer that the call
of @code{distance()} will actually return an @code{Int}.

This kind of type checking is happening from the caller side of course
only -- inside of the @code{distance()} method the compiler can only
deal with a @code{Pair<Any, Any>} type information, unless (as in case
[1]) the method is specialized with different type parameters.


@c --------------------------------------------------------------------
@node Constraint types, Union types, Parameterized types, Types
@section Constraint types

@cindex Constraint types
@cindex Enumeration
@findex = (constraint operator)
@findex in (constraint operator)
@findex >= (constraint operator)

A @dfn{Constraint Type} is a type which is constrained by a certain
subset of possible values.  Examples are numerical values only accepting
specific value ranges, collections only accepting certain values, etc.

@example
(Bool = #t)
(Int in -127 .. 127)
(Keyword in #['apple, 'pear, 'orange, 'banana, 'grapefruit])
@end example

The constraints are not integral part of the type, they are used however
during compilation to detect type mismatch and for possible
optimization.  They are furthermore honoured in multiple dispatch.
I.e. two constraint types only differing in their contraints are treated
differently during multiple dispatch.  The following example:

@example
def meth add-value(self : @@ Cont, value, index : Int)
  if (index == -1)
     self.append(value)
  else
     self.insert(value, index)
@end example

can be rewritten to

@example
def meth add-value(self : @@ Cont, value, index : @@ (Int = -1))
  self.append(value)

def meth add-value(self : @@ Cont, value, index : @@ (Int >= 0))
  self.insert(value, before-index)
@end example

@findex MethodNotImplemented
In this example there's no method specialization for negative numbers
other than -1.  Unless a catch-all fallback implementation is
implemented somewhere calling @code{add-value} with such a negative
value would lead therefore to a @code{MethodNotImplemented} runtime
exception.


@c --------------------------------------------------------------------
@node Union types, Function types, Constraint types, Types
@section Union types

Union types declare that a variable, parameter or such may be of any
type defined in the union type.  Union types are most likely usefull
when defining methods which are appropriate for various types, which are
not directly related.

@example
def meth to-xml(val : @@ (IntNode, StringNode, BoolNode)) : String
  StringBuffer().append("<x>")
                .append(val.to-string)
                .append("</x>")
                .to-string
@end example

Other common usecases for union types are return values:

@example
def alias NumberOrFalse = (Number, Bool = #f)
@end example

Other than constraint types union types influence multiple dispatch.


@c --------------------------------------------------------------------
@node Function types,  , Union types, Types
@section Function types

@example
def f : (Function(a : Int) : Bool)
@end example


@c ====================================================================
@node Bindings, Expressions, Types, Top
@chapter Bindings

A declaration binds a constant, the result of a (constant) expression,
type, class, macro, or function to an identifier.  Every identifier in a
program must be declared.  No identifier may be declared twice in the
same scope.

@example
def const %page-width% = 21
def port = *stdout*
let tmp = self.ack(n)
@end example

@menu
* Scope::                       Scope
* Variable bindings::           Variable bindings
* Immutable bindings::          Immutable Bindings
* Fluid bindings::              Fluid bindings
* Visibility::                  Visibility
@end menu


@c --------------------------------------------------------------------
@node Scope, Variable bindings, Bindings, Bindings
@section Scope

Heather is a proper lexical scoped language.  Bindings are visible
inside the scope they are declare in.  The following scopes exist:

@enumerate
@item Predeclared bindings have universal scope.  They can not be
rebound.
@item Bindings declared on top-level are only visible throughout the
compile unit unless they are exported.  They can be rebound in local
scopes.
@item Bindings imported from other units are visible only in the scope
importing the unit.
@item The scope of an identifier denoting a function parameter is the
function body including the default value expression of other parameters
defined in the same function @emph{following} the parameter.  A function
binding is always visible inside its own body.
@item The scope of an identifier denoting a class or type parameter is
the class or type definition body.
@item The scope of a local binding declared inside a function begins
with its own definition (i.e. it is recursive) and ends at the end of
the innermost containing block.
@item The scope of a local binding declared inside a local block begins
with its own definition (i.e. it is recursive) and ends at the end of
the innermost containing block.
@end enumerate


@c --------------------------------------------------------------------
@node Variable bindings, Immutable bindings, Scope, Bindings
@section Variable Bindings

Every variable must be declared at least once.  On top-level
(``global'') variables are declared using the @code{def} keyword.  Such
declared variables have endless unlimited extent, i.e. they can't be
re-declared.  Only their value can be updated (unless they are declared
to be immutable, see @ref{Immutable bindings}).

In local scope variables are declared using the @code{let} keyword.
These bindings are accessible only inside the scope, the bound values
however survive the scope.  When bindings are accessed from within a
function returned from the scope (@dfn{closure}) the bindings continues
to exist.

@cartouche
@smallformat
@verbatim
variable-def   := global-var-def | local-var-def
global-var-def := `def' [ visibility ] var-def-clause
local-var-def  := `def' var-def-clause
var-def-clause := var-name [ `:' type-clause ] [ `=' init-value ]
init-value     := expression
@end verbatim
@end smallformat
@end cartouche



@c --------------------------------------------------------------------
@node Immutable bindings, Fluid bindings, Variable bindings, Bindings
@section Immutable Bindings

Adding the keyword @code{const} to a declaration let the binding be
treated as @dfn{immutable}.  Such a declaration @emph{requires} an init
value -- which can be, of course, a complex expression.

Init expressions of immutable bindings are evaluated in the same order
as other bindings, and can contain functions with side-effects, etc.

@cartouche
@smallformat
@verbatim
const-def        := global-const-def | local-const-def
global-const-def := `def' [ visibility ] const-def-clause
local-const-def  := `let' const-def-clause
const-def-clause := `const' identifier [ `:' type-clause ] `=' init-value
init-value       := expression
@end verbatim
@end smallformat
@end cartouche


@c --------------------------------------------------------------------
@node Fluid bindings, Visibility, Immutable bindings, Bindings
@section Fluid Bindings

@c todo

Fluid variables (which drill wholes into lexical scoping):

@example
def fluid *stdin* = io|CPort(0)
def fluid *stdout* = io|CPort(1)
def fluid *stderr* = io|CPort(2)
@end example

Such fluid variables can be set later with @samp{let fluid x} to change
temporarily their value:

@example
def fluid x = 5

def g()
  outln(x)

def f()
  outln(x)
  @{
    let fluid x = 11
    g()
  @}
  outln(x)

@result{} 5
   11
   5
@end example


@c --------------------------------------------------------------------
@node Visibility,  , Fluid bindings, Bindings
@section Visibility

Heather supports the following level of visibility control on functions.
This applies both to standalone and generic functions.

@findex public
@findex private
@findex protected
@table @code
@item public
Functions defined in the public scope all visible (and callable) by all
other code modules throughout an application.

@item private
Functions defined as private are visible (callable) from inside the
compilation unit only.  They are not exported to importing units, etc.
The compiler is allowed to strip (if not needed) or inline such
functions.

@item protected
Access to protected functions is only allowed from other functions
defined in the same namespace.  (This is not really a security feature
but more one of documentation of API).  The keyword @code{protected} is
optional; if not given it is the default.
@end table

@example
def private meth find-item(self : @@ MyContainer, obj) @{ ... @}
def public meth add(self : @@ List, obj) ...
@end example

Since visibility in Heather is (mostly) an issue of exporting symbols to
other compile units there's an alternative syntax to the public keyword.
Instead of annotating each public function definition with one the
@code{public} keyword one can control the export with a top-level
@code{export} notation.

@deffn Special export @var{visibility} (@var{symbol1}, @var{symbol2}, ...)
Exports all listed symbols @var{symbol1}, @var{symbol2}, etc. into the
@var{visibility} scope, where @var{visibility} is one of the visibility
keywords above.

@example
export public(insert, remove-at, add, remove, index-of,
              contains?, size)
export protected(internal-size)
@end example
@end deffn

Note that this visibility control should and cannot be used reliable as
a security feature.  Especially for generic functions it is always
possible that a generic function declared to be private can be ``seen''
by other compile units by means of type matching.

Take for instance the following definition:

@example
def private meth crash-detect(one : @@SpaceShip, two : @@Planet)
  display("Spaceship crashs into Planet")
@end example

@findex MethodNotImplemented
The function should be invisible to all other compile units.  If however
in an unrelated second file the following definition and code appears:

@example
def meth crash-detect(one : @@Plane, two : @@House)
  display("Plane crashs into House")

def do-a-crash()
  SpaceShip().crash-detect(Planet())
@end example

on the first view one would expect a @code{MethodNotImplemented}
exception to be raised.  The runtime however folds all three definition
into one generic function and thus the code in @code{do-a-crash}
displays happily @code{SpaceShip crashs into star}.  This cross
influence happens of course only for generic functions defined in the
same namespace.



@c ====================================================================
@node Expressions, Program control, Bindings, Top
@chapter Expressions

@menu
* FunctionCalls::               Function calls
* SlotAccess::                  Access to type slots
* Operators::                   Operators
* Assignment::                  Assignment
* Ranges and Slices::           Ranges and Slices
* On-the-fly iterators::        On the fly iterators
* Closures::                    Closures
@end menu


@c --------------------------------------------------------------------
@node FunctionCalls, SlotAccess, Expressions, Expressions
@section Function calls

Function calls:

  f(a, b, c)

Even if calling a generic function this pattern is kept.  To enhance
readability (and remove parantheses chains) the following form

  a.f(b, c)

is rewritten into

  f(a, b, c)

Additional functions without parameter don't need the parantheses.
Therefore

  f(g(h(i, j)))

is identical to

  h(i, j).g.f

Or

  self.name.empty?('force)

is identical to

  empty?(name(self), 'force)         by:    self.name.empty?('force)
                                         => name(self).empty?('force)
                                         => empty?(name(self), 'force)


@c --------------------------------------------------------------------
@node SlotAccess, Operators, FunctionCalls, Expressions
@section Access to type slots

Since methods/functions are not bound to type, access is always to be done
explicitly to a typed reference:

@example
def class Point
@{
  slot x = 0
  slot y = 0
@}

def add(self : @@ Point, val : @@ Int)
  self.x = self.x + val
  self.y = self.x + val
  self

def add(self : @@ Point, val : @@ Point)
  self.x = self.x + val.x
  self.y = self.x + val.y
  self
@end example

How is this .x and .y implemented?  By default the compiler generates the
relevant access code.  You can overwrite accessors and mutators by
functions.  To access the slots you have to use the slot() and slot!()
special forms:

@example
def x(self : @@ Point)
  self.slot(x)                    -- identical to slot(self, 'x)


def x!(self : @@ Point, val)
  self.slot(x) = val              -- identical to slot!(self, 'x, val)

@end example

The "self.x" and "self.x =" syntax forms are translated into

@example
self.x      ->   x(self)
self.x = 5  ->   x!(self, 5)
@end example


@c --------------------------------------------------------------------
@node Operators, Assignment, SlotAccess, Expressions
@section Operators

Heather's operators are rewritten by the compiler into method calls.  To
implement operator support for custom types and classes implement these
methods.

@findex + (operator)
@findex - (operator)
@findex / (operator)
@findex * (operator)
@findex ** (operator)
@findex mod (operator)
@findex and (operator)
@findex or (operator)
@findex % (operator)
@findex & (operator)
@findex | (operator)
@findex ^ (operator)
@findex << (operator)
@findex >> (operator)
@table @code
@item +
add
@item -
subtract
@item /
divide
@item *
multiply
@item **
exponent
@item mod
modulo
@item and
and
@item or
or
@item %
fold
@item &
bitand
@item |
bitor
@item ^
bitxor
@item <<
shift-left
@item >>
shift-right
@end table

@deftypefn Method Number add (@var{op1}, @var{op2})
Addition; defined on numbers
@end deftypefn

@deftypefn Method Number subtract (@var{op1}, @var{op2})
Subtraction; defined on numbers
@end deftypefn

@deftypefn Method Number divide (@var{op1}, @var{op2})
On Integers and approximate non floating point numbers defined as
integer division; on real and approximate floating point numbers
division
@end deftypefn

@deftypefn Method Number multiply (@var{op1}, @var{op2})
Multiplication; defined on Numbers
@end deftypefn

@deftypefn Method Number exponent (@var{op1}, @var{op2})
Computes the exponent
@end deftypefn

@deftypefn Method Number modulo (@var{op1}, @var{op2})
Modulo arithmetic.  Only defined on integers and approximate non
floating point numbers
@end deftypefn

@deftypefn Method Number logand (@var{op1}, @var{op2})
Logical AND; defined on @code{Bool} only
@end deftypefn

@deftypefn Method Number logor (@var{op1}, @var{op2})
Logical OR; defined on @code{Bool} only
@end deftypefn

@deftypefn Method Number fold (@var{op1}, @var{op2})
Fold operator; defined on @code{String} and alike
@end deftypefn

@deftypefn Method Number bitand (@var{op1}, @var{op2})
Bitwise AND; defined on approximate integer's only
@end deftypefn

@deftypefn Method Number bitor (@var{op1}, @var{op2})
Bitwise OR; defined on approximate integer's only
@end deftypefn

@deftypefn Method Number bitxor (@var{op1}, @var{op2})
Bitwise XOR; defined on approximate integer's only
@end deftypefn

@deftypefn Method Number shift-left (@var{op1}, @var{op2})
Bitwise shift left; defined on approximate integer's only
@end deftypefn

@deftypefn Method Number shift-right (@var{op1}, @var{op2})
Bitwise shift right; defined on approximate integer's only
@end deftypefn


Comparision operators:

@findex == (operator)
@findex <> (operator)
@findex < (operator)
@findex <= (operator)
@findex > (operator)
@findex >= (operator)
@findex <=> (operator)
@table @code
@item ==
equal?
@item <>
unequal?
@item >
greater?
@item >=
greater-equal?
@item <
less?
@item <=
less-equal?
@item <=>
compare
@end table

@deftypefn Method Bool equal? (@var{operand1}, @var{operand2})
Indicates whether @var{operand1} and @var{operand2} are equal.  If
operand1 and operand2 does not have the same type they are not equal by
definition.

TBD.  Numeric values can be equal, even they don't have the same type.
@end deftypefn

@deftypefn Method Bool unequal? (@var{operand1}, @var{operand2})
Indicates whether @var{operand1} and @var{operand2} are not equal.
@end deftypefn

@deftypefn Method Bool greater? (@var{operand1}, @var{operand2})
Indicates whether @var{operand1} is greater than @var{operand2}.
@end deftypefn

@deftypefn Method Bool greater-equal? (@var{operand1}, @var{operand2})
Indicates whether @var{operand1} is greater than or equal to @var{operand2}.
@end deftypefn

@deftypefn Method Bool less? (@var{operand1}, @var{operand2})
Indicates whether @var{operand1} is less than @var{operand2}.
@end deftypefn

@deftypefn Method Bool less-equal? (@var{operand1}, @var{operand2})
Indicates whether @var{operand1} is less than or equal to @var{operand2}.
@end deftypefn

@deftypefn Method Int compare (@var{operand1}, @var{operand2})
Compares @var{operand1} with @var{operand2} and returns a negative
integer if @var{operand1} is less than @var{operand2}, a zero if it is
equal and a positive integer if is greater.
@end deftypefn


@c --------------------------------------------------------------------
@node Assignment, Ranges and Slices, Operators, Expressions
@section Assignment

@c todo


@c --------------------------------------------------------------------
@node Ranges and Slices, On-the-fly iterators, Assignment, Expressions
@section Ranges and Slices

Basic ranges are exclusive, so the range [5, 100) is written as:

@example
5 .. 100
@end example

Whereas [5, 100] is written as:

@example
5 ... 100
@end example

Give the step parameter:

@example
5 .. 100 by 5
@result{} 5, 10, 15, ..., 95
@end example

Ranges are used for instance to slice vectors and strings:

@example
"hello world"[3 .. 6]
@result{} "lo "

"hello world"[3 ... 6]
@result{} "lo w"

"hello world"[3 .. 8 by 2]
@result{} "l o"
@end example


@c --------------------------------------------------------------------
@node On-the-fly iterators, Closures, Ranges and Slices, Expressions
@section On the fly iterators

The @code{then-while} ternary operator is used to express iterators on
the fly.  Its most common usage is in for loops:

@example
for (i : Int = 0 then i + 1 while i < 10) @emph{body}

def value-iterators(values : Int[])
  let i = 0
  values[i] then values[i.incr!] while i + 1 < values.num-items
@end example



@c --------------------------------------------------------------------
@node Closures,  , On-the-fly iterators, Expressions
@section Closures

@example
#function(a : Real, b : Real) : Int @{ @}
@end example


@c ====================================================================
@node Program control, Program structure, Expressions, Top
@chapter Program control

@menu
* Blocks::                      Blocks
* Loops::                       Loops
* Conditionals::                Conditionals
* Conditions::                  Conditions
* Concurrency::                 Concurrent evaluation
* NonLocalExists::              Non local exists
* Multiple returnvalues::       Multiple returnvalues
@end menu


@c --------------------------------------------------------------------
@node Blocks, Loops, Program control, Program control
@section Blocks

Code blocks are sequences of statements.  The last statement's return value
gives the return value of the complete block.  Blocks are atomic and
therefore can be put whereever a single expression is expected (i.e. even
in default parameter init value places):

@example
def f(x = @{ let p = Properties()
            while (p.next?) @{
              if (not(p.nil?))
                break(p.value)
            @}
            else
              #f
          @})
   @emph{body}
@end example


@c --------------------------------------------------------------------
@node Loops, Conditionals, Blocks, Program control
@section Loops

Heather provides three major loop operators: @code{for}, @code{while},
and @code{until}.

The returnvalue of the loop body's last statement gives the return value
of the complete loop statements.  Each loop form takes an optional
@code{else} branch, which is evaluated if the loop's body is never
entered:

@example
let first-name = for (n in values)
                   break(n)
                 else
                   #nil
@end example

If no @code{else} branch is given the return value of such a loop is
@code{#unspecified}.

@deffn Special for (@var{loop-exprs}) @var{expr}
@deffnx Special for (@var{loop-exprs}) @var{expr} @
        @code{else} @var{alternate}

This is the generalized loop construct, which depends on the
@var{loop-exprs} given.  Any number of @var{loop-exprs} can be given,
@code{for} loops until at least one of these evaluate to false.  If
@var{loop-exprs} is empty the for-loop iterates infinite unless is
terminated by other means (e.g. early @code{return}, a break statement,
an exception).

@var{loop-exprs} are either boolean operators or one of the following
binding constructs:

@table @code
@item @var{var} [@code{:} @var{type}] @code{in} @var{collection}
@var{collection} is evaluated and stored in a (temporary, invisible)
fresh binding.  Its result must implemented the @code{Iteratable} type.
A new binding @var{var} is created and bound on each loop to the next
available value from @var{collection}'s return value.  If
@var{collection} is exhausted (its @code{next?} method returns #f) this
loop expression stops the loop.

@item @var{var} [@code{:} @var{type}] @code{=} @var{first} @code{then} @var{step} @code{while} @var{test}
@itemx @var{var} [@code{:} @var{type}] @code{=} @var{first} @code{then} @var{step}
@var{first} is evaluated and bound to a fresh variable @var{var}.  Then
@var{test} is evaluated and if true the complete loop expression is said
to be successful.  On the next iteration @var{step} is evaluated and its
value is bound to @var{var}; @var{test} is evaluated again and if true
the loop expression is successful.  The variant without @code{while}
test has no explicit termination expression and is therefore, as loop
expression, always successful.
@end table

To iterate over all elements of a collection:

@example
for (e : Elt in values)
  outln(e)
@end example

To enumerate numbers two typical patterns exist.  Both should be
optimized in the same way by the compiler:

@example
for (i : Int in 0 .. 100 by 2) outln(i)
for (i : Int = 0 then i + 2 while i <= 100) outln(i)
@end example

To traverse a linked list (given that @code{tail} gives the next node in
the list:

@example
for (n : Node = root-element then n.tail while n <> #nil) outln(n)
@end example

Multiple Loop expressions are possible of course:

@example
def count-until(root : Node, element : Node) : UInt
  for (n : Node = root then n.tail while n <> #nil,
       i : UInt = 0 then i + i,
       n <> element)
    i
  else
    0
@end example
@end deffn

@deffn Special while (@var{test}) @var{expr}
@deffnx Special while (@var{test}) @var{expr} @
        @code{else} @var{alternate}
The @code{while} loop evaluates @var{test} before each loop; it
evaluates @var{expr} only if @var{test} is true.  The last @var{expr}'s
value becomes the return value of the complete construct.
@end deffn

@deffn Special until (@var{test}) @var{expr}
@deffnx Special until (@var{test}) @var{expr} @
        @code{else} @var{alternate}
Analog to @code{while} @code{until} loops while @var{test} is false.
@end deffn


@c --------------------------------------------------------------------
@node Conditionals, Conditions, Loops, Program control
@section Conditionals

@deffn Special if (@var{test}) @var{consequent}
@deffnx Special if (@var{test}) @var{consequent} @code{else} @var{alternate}
@var{test} must be a boolean test; it is evaluated and depending on its
returnvalue either @var{consequent} or @var{alternate} is evaluated.
The return value of the if expression is the evaluated branch's return
value.  For the variant without @code{else} branch the return value is
@code{#unspecified} if @var{test} in false.
@end deffn

@deffn Special select ([@var{value}, [@var{comparator}]]) @
       @{ @var{tests} @}

@example
select (test) @{
  test -> expr
  test -> expr
  otherwise -> expr
@}
@end example

@example
select (a) @{
  \a -> if (not(done))
          do-it
        else
          do-something-different
  otherwise -> outln("nothing applies")
@}
@end example

If the parameter list for select is empty each test is expected to be a
conditional expr:

@example
select () @{
  (c == \a or
   c == \b or
   c == \c)            -> @emph{expr}
  (c in #[\a, \b, \c]) -> @emph{expr}
@}
@end example
@end deffn


@c --------------------------------------------------------------------
@node Conditions, Concurrency, Conditionals, Program control
@section Conditions

It's possible to add a hook to a block which is called whenever the
block is left, either by unroll or by ``normal'' code flow:

@cindex exit handler
@findex on exit
@findex exit
@deffn Handler on @code{exit} (@var{value}) @var{expr}

Value is the return value of the block's last statement.  Normally the
exit handler will return this without modification.

Not that the @code{on exit} handler is actually inside the block for
which it is declared.  It can therefore access local bindings etc.  On
the other side in examples like this:

@example
let stream = io|FileInputPort(name)
for (i = 0 .. 100) @{
  on exit(v)
  @{
    stream.close
  @}
  @emph{do-something}
@}
@end example

the exit hook would be called for each loop step.  The author mostly likely
intended this:

@example
let stream = io|FileInputPort(name)
on exit(v)
@{
  stream.close
@}

for (i = 0 .. 100) @{
  @emph{do-something}
@}
@end example
@end deffn

Similar to @code{on exit} special conditions can be trapped:

@cindex exception handler
@findex on signal
@findex signal
@deffn Handler on @code{signal} (@var{value} @code{:} @var{type}) @
       @var{signal-expr}

This declares a condition handler for a condition of type @var{type}.
Whenever a condition raised (using @code{raise}) the first matching
condition handler is called.
@end deffn

During evaluation of @var{signal-expr} two special functions are
available: @code{continue(val)} and @code{raise()} without parameter.

@defun continue (@var{value})
Returns to the place from which @code{raise()} was
called injecting @var{value} as new returnvalue to the raise expression.
@end defun

@defun raise ([@var{condition}])
When called without parameter propagates the condition handling to the
next matching condition handler.  @code{raise()} without parameter does
not start a new condition signal chain, but passes control upwards.

When called with parameter @var{condition} is raised and a new signal
chain is started, which can be handled inside the control handler.
@end defun

If the condition handle is neither left early with @code{continue} or
@code{raise} the stack is unrolled and @var{signal-expr}'s return
value becomes the return value of the block in which the condition
handler has been declared.

If both exit and condition handler had been declared, the condition
handler is called first and its return value is passed as input to the
exit handler.


@c --------------------------------------------------------------------
@node Concurrency, NonLocalExists, Conditions, Program control
@section Concurrent evaluation

To run a portion of code in its own thread one can call a function using
the special form @code{spawn}.

@deffn Special spawn @var{function-call}
Starts @var{function-call} in a new thread and returns immediately to
the normal control flow.  If @var{function-call}'s return value is used
in the following code (e.g. it is bound to a name, assigned to a
variable, or directly passed as argument to another function call) the
compiler arranges an automatic @code{sync} point to wait on
@var{function-call}'s return before continuing.  To the calling site the
return value of a spawned function forms a @dfn{promise}.

It is possible to spawn multiple functions in sequence before using
their return values.  The compiler may arrange for a joint sync point
here.

@example
def fib(n : Int) : Int
  if (n < 2)
    n
  else @{
    let x = spawn fib(n - 1)       [1]
    let y = spawn fib(n - 2)       [2]
    x + y                          [3]
  @}
@end example

At [1] a new thread is started; the return value of @code{fib(n - 1)} is
a promise until used at [3].  The same applies for the line at [2].
@end deffn

Spawned functions whose return value is not used survive their parent
function, i.e. the context from where they have been spawned.

It is possible to add explicite synchronization points by using the
@code{on sync} handler form:

@findex on sync
@findex sync
@deffn Handler on @code{sync} (@var{res1}, @var{res2}, ...) @var{expr}
Waits for the resources @var{res1}, @var{res2}, etc. to become
available.  Resources are

@table @asis
@item Promises
A promise is said to be available when its value is computed.  Is the
promise backed by a spawned function this must have finished and
returned its value.
@item Mutexes
A mutex is said to be available if the waiting thread has successfully
gained access to it.
@end table

@example
on sync(pending-ticket-list-mutex,
        database-mutex)
@{
  pending-ticket-list.append(...)
  database.update
@}
@end example
@end deffn


@c --------------------------------------------------------------------
@node NonLocalExists, Multiple returnvalues, Concurrency, Program control
@section Non local exists

@deffn Special break (@var{return-value})
Stops the current inner-most loop and sets @var{return-value} as its
return value.  Note that the optional @code{else} branch of the
enclosing loop is not evaluated.  Any exit handlers in the scope until
the loop are evaluated before.
@end deffn

@deffn Special return (@var{return-value})
Returns from the current @emph{function} and sets @var{return-value} as
its return value.  Any exit handlers in the scope until the function are
evaluated before.
@end deffn

@deffn Macro with-break () @var{body-expr}
@deffnx Macro with-break (@var{break-symbol}) @var{body-expr}
@deffnx Macro with-break (@var{break-symbol} = @var{function}) @var{body-expr}
Defines a new scope and binds a non-local exist function to the name
@var{break-symbol} or @code{break} if non symbol is given.
@var{function} must be a function definition taking one argument.
Analog to the @code{break} special this new binding allows to exit a
scope quickly, even from deep nested locations.

@example
def xyz(collection)
  with-break(outer-break)
  @{
     let keys = collection.keys
     for (k in keys)
     @{
        for (v in collection.values-for-key(k))
        @{
          if (v.is-not-valid?)
            outer-break(#f)
          else if (v.nil?)
            break(#f)
        @}
     @}
  @}
@end example
@end deffn


@c --------------------------------------------------------------------
@node Multiple returnvalues,  , NonLocalExists, Program control
@section Multiple returnvalues

@c todo

@example
def f()
   (1, 2, 3, 4)

def g()
  let (a, b, c, d) = b.io|Port().read(4)

-- variable rest argument
let (x, b ...) = get-values()
@end example



@c ====================================================================
@node Program structure, Macros, Program control, Top
@chapter Program structure

@menu
* Namespaces::                  Namespaces
* Import::                      Importing modules
@end menu


@c --------------------------------------------------------------------
@node Namespaces, Import, Program structure, Program structure
@section Namespaces

@cindex Namespaces

@deffn Special namespace @var{tag} (@var{namespace})
@deffnx Special namespace @var{tag}
Declares and use the namespace of a @sc{compile unit}.

This sets the namespace for the following functions, types, macros, and
variables.  It is valid until the end of the source file or the next
namespace declaration.

@example
namespace heather("eyestep/heather 1.0:core")
@end example

The variant without full id data simply switches the current governing
namespace to a previous defined one.  It requires a previous full
namespace declaration, and is therefore usefull for source files with
multiple namespaces.

@example
namespace io
@end example

simply switches the current governing namespace to @code{io}.
@end deffn

Namespaces have two names, the short (or ``tag'') name and the full id
(the ``full name'').  The full name is any identifying string; for the
default heather libraries this is a kind of public id, other projects
may use URLs, etc.  Namespaces are compared by full id only, but since
this can be clumsy in code normally the tag name is used.  The common
tag @code{io} is actually defined as:

@example
namespace io("eyestep/heather 1.0:input-output")
@end example

@findex | (namespace marker)
If names are unique throughout all namespaces visible in a certain portion
of code there's no need to indicate the namespace.  If there are multiple
equally named functions or types in different namespaces however the fully
qualified name has to be used by prepanding the namespace tag to the
symbol (delimited by the namespace marker @code{|}):

@example
io|InputPort()
zip|InputPort()
@end example

gives the @code{InputPort} type from the @code{io} and the @code{zip}
namespace respectively.

Note that the @code{|} must not be separated by whitespace.

The namespace have to be given inside of method call chains also if
necessary:

@example
self.io|write()
@end example

Namespace defines (i.e. tag name to full id mapping) are imported from
loaded files; the namespace defined in the file does not extend,
however, into the importing file.


@c --------------------------------------------------------------------
@node Import,  , Namespaces, Program structure
@section Import

Importing external modules.  The statement

@deffn Special import (@var{module-id})
Imports a module with @var{module-id} and makes its definitions known
in the current compile unit.  How @var{module-id} is mapped to the
specific header is implementation dependant.  One possible way is to
treat it as a base file name and look it up in a search path.

@example
import(io)
import(collection)
@end example
@end deffn


@c ====================================================================
@node Macros, Appendix, Program structure, Top
@chapter Macros

Different kind of macro styles:

FUNCTION MACROS.

Look exactly and are called like functions:

  def macro min @{
     @{ min (?a:expr, ?b:expr) @} -> @{ @{ let tmp-a = ?a tmp-b = ?b
                                 if (tmp-a > tmp2) tmp-b else tmp-a @} @}
  @}

or in a local scope:

  let macro min @{
     @{ min (?a:expr, ?b:expr) @} -> @{ @{ let tmp-a = ?a tmp-b = ?b
                                 if (tmp-a > tmp2) tmp-b else tmp-a @} @}
  @}

usage:

  min(100, 200)


DEFINITION MACROS

Look like a define and/or let:

  def macro func-variable @{
      @{ def func-variable ?name:name = ?e:expr @} ->
        @{ def ?name ## -var = ?e
          def ?name () ?name ## -var
          def ?name (value) @{ ?name ##-var = value
                                 value @} @}
      @{ let func-variable ?name:name = ?e:expr @} ->
        @{ let ?name ## -var = ?e
          let ?name () ?name ## -var
          let ?name (value) @{ ?name ##-var = value
                              value @} @}
  @}


STATEMENT MACROS

Look like a statement like for, while, etc.

  def macro unless @{
      @{ unless (?test:expr) ?b:body @} -> @{ if (not(?test)) ?b @}
  @}


  def macro with-open-file @{
    @{ with-open-file (?stream:name, ?name:string) ?e:expr @} ->
      @{
        let ?stream = FileInputPort(?name, 'read)
        on exit(value) @{
          if (?stream.nil?) close(?stream)
          value
        @}

        ?e
      @}
  @}


Multiple variant patterns and subpatterns:

  def macro funcvar @{
    @{ def funcvar ?name:name @} -> @{ def ?name ## -var = #nil
                                  def ?name () ?name ## -var
                                  def ?name (value) @{ ?name ## -var = value
                                                      value @} @}
    @{ def funcvar ?name:name = ?e:expr @} ->
                                @{ def ?name ## -var = ?e
                                  def ?name () ?name ## -var
                                  def ?name (value) @{ ?name ## -var = value
                                                      value @} @}
  @}

is identical to:

  def macro funcvar @{
    @{ def funcvar ?name:id #?opt-expr @} ->
                      @{ def ?name ## -var = ?opt-expr
                        def ?name () ?name ## -var
                        def ?name (value) @{ ?name ## -var = value
                                            value @} @}

  opt-expr:
    @{ @} -> @{ @}
    @{ = ?e:expr @} ->  @{ ?e @}
  @}


Conditional evaluation of macros (meta programming):

  def macro compile-only-if @{
    @{ compile-only-if(?test:bool) ?e:expr @} ->
      @{
        #if (?test)
          ?e
      @}
  @}


  basic constructs like if, else, let can be set and evaluated during
  macro-expansion time.  The form is then called: #if, #else, #let.  For
  the example above ?test **must** be a constant (or another macro
  expanding to a constant), since runtime code is not evaluated during
  macro expansion of course.


Optional macro parameters:

  def macro xxx @{
    @{ xxx(x: ?a = 5, y: ?b = 6) @} -> @{ yyy(m: ?a, n: ?b) @}
    @{ xxx(args ...) @} -> @{ yyy(args) @}
  @}


@c ====================================================================
@node Appendix, Function Index, Macros, Top
@chapter Appendix

@menu
* Ideas::                       Ideas
@end menu

@c --------------------------------------------------------------------
@node Ideas,  , Appendix, Appendix
@section Ideas

@subsection Measures

@example
21'cm
12.15'ft
21'm/s
412'px

def measure Length

-- scalar definition; no default transformation
def measure Meter ('m) : Length

-- derived definition; basic measure is Meter with a factor of 100
def measure Centimeter ('cm, Meter, 100) : Length

-- derived definition; basic measure is Meter with a factor of 1000
def measure Millimeter ('mm, Meter, 1000) : Length

def measure Inch ('in) : Length

-- additional transformations
def meth transform(from : @@ Centimeter, to : @@ Millimeter)
  Millimeter(from.value * 10)

def meth transform(from : @@ Millimeter, to : @@ Inch)
  Inch(from.value * 25.4)
@end example

Measures are useful to have a specific notation for (mostly) numeric
constants.  They give values a certain semantic by putting them into a
specific type domain.  It is a type error to assign a pixel value to a
price tag.

Unclear: what is the base type of a measure?  Int? Number? Real?  Is it
definable?

@example
def measure Pixel('px) : Int
@end example


@c ====================================================================
@node Function Index, Concept Index, Appendix, Top
@unnumbered Index of functions

@printindex fn

@c ====================================================================
@node Concept Index,  , Function Index, Top
@unnumbered Index of concepts

@printindex cp

@bye

