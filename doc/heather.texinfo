\input texinfo @c -*-texinfo-*-
@c %**start of header
@setfilename heather.info
@settitle heather -- an experimental programming language
@finalout
@setchapternewpage odd
@c %**end of header

@c This file is processed by Arc! Placeholders are surrounded by &
@c (amp) and not by @ (at) as normally, since Texinfo uses @ as markup maker!
@set VERSION 0.0.1
@set COPYRIGHT 2002, 2003, 2009 Gregor Klinke

@ifinfo
This file documents @emph{heather}, an experimental programming language tool

Copyright (C)  @value{COPYRIGHT}.

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.3
or any later version published by the Free Software Foundation;
with no Invariant Sections, no Front-Cover Texts, and no Back-Cover
Texts.  A copy of the license is included in the section entitled ``GNU
Free Documentation License''.

@ignore
Permission is granted to process this file through TeX and print the
results, provided the printed document carries copying permission
notice identical to this one except for the removal of this paragraph
(this paragraph not being relevant to the printed manual).
@end ignore

Permission is granted to copy and distribute modified versions of this
manual under the conditions for example copying, provided that the entire
resulting derived work is distributed under the terms of a permission
notice identical to this one.

Permission is granted to copy and distribute translations of this manual
into another language, under the above conditions for modified versions,
except that this permission notice may be stated in a translation approved
by the Foundation.
@end ifinfo

@titlepage
@title heather
@subtitle an experimental programming language
@subtitle for heather vr. @value{VERSION}
@author by Gregor Klinke

@page
@vskip 0pt plus 1filll
Copyright (C)  @value{COPYRIGHT}.

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.3
or any later version published by the Free Software Foundation;
with no Invariant Sections, no Front-Cover Texts, and no Back-Cover
Texts.  A copy of the license is included in the section entitled ``GNU
Free Documentation License''.
@end titlepage

@c All the nodes can be updated using the EMACS command
@c texinfo-every-node-update, which is normally bound to C-c C-u C-e.
@node Top, Introduction, (dir), (dir)

@ifinfo
This manual documents @emph{heather}, an experimental programming
language.  It refers to version @value{VERSION}.
@end ifinfo

@c All the menus can be updated with the EMACS command
@c texinfo-all-menus-update, which is normally bound to C-c C-u C-a.

@menu
* Introduction::                Introduction
* Specification::               Specification
* Copying::                     Copying
* Function Index::              Index of functions
* Concept Index::               Index of concepts
@end menu



@c ====================================================================
@node Introduction, Specification, Top, Top
@chapter Introduction

Heather is an generic multiparadigm programming language.  At short list
of its features:

@itemize
@item object oriented ("everything's an object")
@item multi dispatch functions
@item first class functions, classes
@item fully lexical scoped
@item strong functional aproach (while being not fully functional)
@item garbage collected
@item returnable exceptions
@item compiled, though not required by specification
@end itemize


@c ====================================================================
@node Specification, Copying, Introduction, Top
@chapter Specification

@menu
* Notation::                    Notations
* Functions::                   Functions
* Types::                       Types
* Variables::                   Variables and constants
* FunctionCalls::               Function calls
* SlotAccess::                  Access to type slots
* Namespaces::                  Namespaces
* Import::                      Import
* Blocks::                      Blocks
* Loops::                       Loops
* Conditionals::                Conditionals
* Ranges and Slices::           Ranges and Slices
* On-the-fly iterators::        On the fly iterators
* Conditions::                  Conditions
* Closures::                    Closures
* Macros::                      Macros
* Ideas::                       Ideas
* ReserverdWords::              Reserved words
* Examples::                    Examples
@end menu


@c --------------------------------------------------------------------
@node Notation, Functions, Specification, Specification
@section Notations

@c ....................................................................
@subsection Symbols

@example
*stdout*
%some-constant%
-a-string-
_a_string_
_a/string_
@end example


@c ....................................................................
@subsection Chars

@example
\a
\space
\u41h
\nl
@end example


@c ....................................................................
@subsection String

@example
"abc"
"hello world"
"Usage: cmd OPTIONS\nl;"
"a string"
"a \nl;string"
"a \tab;string"
"a \\string"
"a \"string"
"a \A;string"
"a \u41h;string"
@end example


@c ....................................................................
@subsection Keywords

@example
'symbol
'hello-world
@end example


@c ....................................................................
@subsection Arrays

@example
a constant array: #[1, 2, 3, 4, 5]
@end example


@c ....................................................................
@subsection Vector

@example
#(1, 2, 3)
@end example


@c ....................................................................
@subsection Dictionary

@example
#("abc" -> #[1, 2, 3],
  "def" -> 'symbol,            -- symbol
  "xyz" -> \a,                 -- char
  "mmm" -> \u41h,              -- char
  "ch1" -> \space              -- char
)
@end example


@c ....................................................................
@subsection Numbers

Notation:
@example
1234                           -- decimal
100h                           -- hexadecimal
100y                           -- binary
100o                           -- octal
@end example

Type notation:
@example
1234                           -- precise integer
123.4                          -- precise real
12/34                          -- precise rational
12 + 34i                       -- precise complex
12.3+34j                       -- precise complex
1.23e-45                       -- precise integer (exp. not.)

123t                           -- (inexact) octet
123s                           -- (inexact) signed short
123us                          -- (inexact) unsigned short
123w                           -- (inexact) word
123uw                          -- (inexact) unsigned word
123l                           -- (inexact) long
123ul                          -- (inexact) unsigned long
123.4f                         -- (inexact) ieee754 float
123.4d                         -- (inexact) ieee754 double
123.4dl                        -- (inexact) ieee754 long double
@end example

Exact and inexact numbers.

Exact numbers: Number )= complex )= real )= rational )= integer

@ftable @code
@item Number
@item ComplexNumber
@item Real
@item Rational
An rational number, e.g. @code{1/3}, or @code{-1/17}.
@item Integer
@end ftable

Inexact numbers:

@ftable @code
@item Octet
8bit unsigned integer
@item Short
16bit signed integer
@item UShort
16bit unsigned integer
@item Word
32bit signed integer
@item UWord
32bit unsigned integer
@item Long
64bit signed integer
@item ULong
64bit unsigned integer
@item Float
32bit ieee754 float
@item Double
64bit ieee754 double
@item LongDouble
128bit ieee754 long double
@end ftable


@smallexample
   +------+
   |Number|
   +------+
      ^  ^
      |  \--------------\
      |                 |
   +-----------+    +-------------+
   |ExactNumber|    |InexactNumber|<------------\
   +-----------+    +-------------+<----\    |  |
      ^                ^  ^^  ^      |  |    |  |
      |                |  ||  |      |  |    |  |
   +-------------+ +-----+||+-----+  |+----+ |+----+
   |ComplexNumber| |Octet||||Short|  ||Word| ||Long|
   +-------------+ +-----+||+-----+  |+----+ |+----+
      ^                   ||+------+ |+-----+|+-----+
      |                   |\|UShort| \|UWord|\|ULong|
   +----+                 | +------+  +-----+ +-----+
   |Real|                 |
   +----+                 | +-----+
      ^                   |-|Float|
      |                   | +-----+
   +--------+             | +------+
   |Rational|             \-|Double|
   +--------+               +------+
      ^
      |
   +-------+
   |Integer|
   +-------+
@end smallexample



@c ....................................................................
@subsection Basic constants

@example
#nil
#true #t #false #f
#eof
@end example


@c --------------------------------------------------------------------
@node Functions, Types, Notation, Specification
@section Functions

Function are standalone function not bound to any particular type.
Functions are resolved by "name" only.  There's nothing like
type-overwriting, etc.

@cindex functions, defining
@findex def [function]
@findex let [function]
@deffn Special def @var{name} ([@var{parameters}]) @
       [@code{:} @var{return-type}] @
       @var{function-body}
@deffnx Special let @var{name} ([@var{parameters}]) @
        [@code{:} @var{return-type}] @
        @var{function-body}

Defines a function with @var{parameters} and the body
@var{function-body} bound to @var{name}.  The @var{function-body} is
expected to be a @emph{single} expression, i.e. for a multi expression
body it must be written as a block.  As an exception function bodies on
top-level, i.e. where functions are defined with the @code{def} keyword,
are delimited by the next @code{def} keyword or the file end.

Functions are always defines in recursive mode, i.e. a function
@var{name} can ``see'' (i.e. call) itself recursively.

For the way to define the @var{parameters} see below.

@example
def ack(x : Int, y : Int) : Int
  if (x == 0)
    y + 1
  else if (y == 0)
    ack(x - 1, 1)
  else
    ack(x - 1, ack(x, y - 1))
@end example
@end deffn

Methods in contrast are generic functions specialized by one or multiple
parameters to certain types.  They are declared using the @code{meth}
modifier.

@cindex generic functions, defining
@findex def meth
@findex meth
@deffn Special def @code{meth} @var{name} ([@var{parameters}]) @
       [@code{:} @var{return-type}] @
       @var{function-body}

Defines a generic function (a @dfn{method}) named @var{name}.

Methods are resolved by name and specialized parameters.  Parameters are
specialized by adding the @code{@@} to their type declaration.  Only
positional parameters can be specialized:

@example
def meth name(self : @@ MySomething, value : @@ Int)
  @emph{body}
@end example

Generics must be defined at least once.  Multiple generic definition
must be compatible.  A method specialization must not be defined before
its generic method definition.

It's possible to define an empty, i.e. abstract, generic function:

@example
def meth compare(one : @@ OneType, two : @@ TwoType) : Bool ...
@end example

Note the ellipsis @code{...} at the end of the line.
@end deffn


@defun next-method ()
Inside generic functions @code{next-method} calls the next overwritten
method.
@end defun


@c ....................................................................
@subsection Parameters

Positional parameters:

@example
def f(a, b, c) @emph{body}
@end example

are used as:

@example
f(1, 2, 3)
@end example


@c ....................................................................
@subsection Keyword parameters

Heather function can use named arguments with @dfn{keyword parameters}.
These are declared by adding a default value to the parameters name:

@example
def f(a = 5, b = "hello world", c = @{ let x = 5
                                      x * x @})
  @emph{body}
@end example

The default value can be any valid expression, even complete block (as
to be seen for the parameter @code{c} in the example above.  This can be
used like in the following examples:

@example
f(a: 11, b: "N.N.", c: 255)
@result{} a -> 11
   b -> "N.N."
   c -> 255

f()
@result{} a -> 5
   b -> "hello world"
   c -> 25

f(c: 7, a: 0)
@result{} a -> 0
   b -> "hello world"
   c -> 7
@end example

By default the keyword and the parameter name are identical (like @code{a} and
@code{a:} in the examples above).  It is possible to specify a
particular keyword name in the declaration however:

@example
def f(fst: a = 5, snd: b = "hello world", trd: c = @{ let x = 5
                                                    x * x @})
  @emph{body}

f(fst: 127, trd: 8, snd: "/")
@result{} a -> 127
   b -> "/"
   c -> 8
@end example


@c ....................................................................
@subsection Optional parameters

Additionally to positional and keyword parameters it is possible to
define a @dfn{rest parameter} which takes all arguments additionaly to
be found in a function call:

@example
def f(args ...)
@end example

When called it puts all additional parameters, including all keyword
arguments which are not matching, into a immutable array:

@example
f()
@result{} args -> #[]

f(1, 2, 3, 4)
@result{} args -> #[1, 2, 3, 4]

f(#[1, 2, 3, 4])
@result{} args -> #[#[1, 2, 3, 4]]

f(a: 1, b: 2, 3 4)
@result{} args -> #['a, 1, 'b, 3, 4]
@end example


@c ....................................................................
@subsection Mixture of the parameter types

When using positional, keywords and optional parameters at the same time
in a function declaration, they have to appear in the following order:

@enumerate
@item positional
@item keyword
@item optional
@end enumerate

@example
def f(a, b, c, d = #t, e = 25, f ...)
@end example

The same basic order applies to function calls.  Even if keyword
arguments can be ordered in any way, they always have to follow
positional arguments.

Keyword arguments are always ordered in lexicographical way when listed
in an optional argument:

@example
f(1, 2, 3)
@result{} a -> 1
   b -> 2
   c -> 3
   d -> #t
   e -> 25
   f -> #[]

f(4, 5, 6, e: 127, "hello world", "sic est")
@result{} a -> 4
   b -> 5
   c -> 6
   d -> #t
   e -> 127
   f -> #["hello world", "sic est"]

f(1, 2, 3, z: 1, g: 2, h: 3)
@result{} a -> 1
   b -> 2
   c -> 3
   d -> #t
   e -> 25
   f -> #['g, 2, 'h, 3, 'z, 1]
@end example




@c --------------------------------------------------------------------
@node Types, Variables, Functions, Specification
@section Types

Heather's type system is nominative, i.e. types are identified by name.
Types can be parameterized, constrained, or being complex sets of types
(union types).  Types are first class, i.e. types have a runtime
representation and are objects themselves.

Types are orthogonal to namespaces.  Methods and functions are not
@sc{members} of types; neither is it possible to define sub-classes or
enumerations inside of types.  Methods are bound by specialized
parameters to types, are otherwise self contained however.

@cindex multiple inheritance
Heather supports multiple inheritance.  All inherited types must not
conflict in slot names, neither in public not private ones.  If two
inherited types have the exactly same slot (they are identical in name,
type and initial value), they share the same physical allocation space.
Cyclic inheritance is not possible (of course).

@menu
* Defining types::              Defining types
* Slots::                       Slots
* Finalization::                Finalization
* Array types::                 Array types
* Parameterized types::         Parameterized types
* Constraint types::            Constraint types
* Union types::                 Union types
* Function types::              Function types
@end menu


@c ....................................................................
@node Defining types, Slots, Types, Types
@subsection Defining types

@cindex classes
@cindex classes, defining
@cindex types
@cindex types, defining

Heather distinguishes between @dfn{type} and @dfn{class}.  Every class
has exactly one type, but not every type is represented by a class.
A union type for example forms a specific type without a class.  It
therefore cannot be instantiated.

There are three forms for defining types.  The first, @code{def class},
is used for defining class, i.e. types which has a defined run-time
representation with a certain memory layout, and which are
(ultimatively) intended to be instantiated.  The second, @code{def
type}, is used to define logical types, which are not supposed to have a
run-time allocation representation.  The third, @code{def alias}, is a
shortcut definition, where a type declaration is bound to a new name.

@findex def class
@findex class
@deffn Special def @code{class} @var{name} @
       [(@var{param1}, @var{param2}, ...)] [@code{:} @var{inheritance}] @
       @{ [ @var{slots} ] @}
Define a class @var{name} with @var{params}.  The class will have
derive from @var{inheritance} and have @var{slots} slots.

If @var{params} is a non empty list of variables the resulting type is
set to be @dfn{parameterized}.  These parameters are @dfn{type
parameters}, which can be used in type declarations on the slot
definitions in @var{slots} and from related method definitions.

@var{Inheritance} is either a single type declaration or a list of comma
separated type declarations.  This gives the full inheritance definition
of the resulting type.  The order of the types gives their specifity.

For @var{slots} it is valid to be empty.

Every class ultimatively inherits from @code{Object}.  This type is
automatically added to the inheritance list when missing.
@end deffn


@findex def type
@findex type
@deffn Special def @code{type} @var{name} @
       [(@var{param1}, @var{param2}, ...)] @
       [@code{:} @var{inheritance}]

Defines a new type @var{name} which is derived from @var{inheritance}.
@var{inheritance} is either a simple type declarations or a list of type
declarations.

@example
def type RandomAccessStream : (InputStream, OutputStream,
                               RepositionableStream)
@end example

The resulting type is a new type with its own run-time representation
which is different to those of its inherited types -- even in case of
single inheritance.

Other than classes a type does not automatically inherit from
@code{Object}; it is possible to have types without inheritance at all.
Such a type is useful for defining type signatures (aka ``interface''s
in Java) and even mixins:

@example
def type Comparable

def meth compare(one : @@ Comparable, two : @@ Comparable) : Int ...

def meth less?(one : @@ Comparable, two : @@ Comparable) : Bool
  (one <=> two) < 0

def meth equal?(one : @@ Comparable,
                two : @@ Comparable) : Bool
  (one <=> two) == 0

def meth less-equal?(one : @@ Comparable,
                     two : @@ Comparable) : Bool
  (one <=> two) <= 0

def meth greater?(one : @@ Comparable,
                  two : @@ Comparable) : Bool
  (one <=> two) > 0

def meth greater-equal?(one : @@ Comparable,
                        two : @@ Comparable) : Bool
  (one <=> two) >= 0
@end example

Every class or type inheriting from @code{Comparable} automatically gets
the compare operators @code{<}, @code{<=}, @code{>}, etc. and only has
to specialize the method @code{compare} (as implementation of the
operator @code{<=>}).  This method is kept as abstract generic function
but bound to the @code{Comparable} type.
@end deffn


@findex def alias
@findex alias
@deffn Special def @code{alias} @var{name} = @var{type}
Defines an alias for @var{type}.  @var{name} and @var{type} afterwards
are totally synonym, i.e. @var{name} is not considered a new type.  The
only purpose of this form is to provide a more readable form for
@var{type}.

@example
def alias UserTagMap = HashMap(String, UserTag(String, Int))

def meth add-tags(tags : @@ UserTagMap) ...                    [1]
def meth add-tags(tags : @@ HashMap(String,
                                   UserTag(String, Int))) ... [2]
@end example

The two method declarations at [1] and [2] are completely identical.

(Alias definitions are comparable to @code{typedef}s in C and C++.)
@end deffn


@c ....................................................................
@node Slots, Finalization, Defining types, Types
@subsection Slots

Slots are defined as variables inside the block of a type declaration using
the special @code{slot} define form:

@example
def class Point : Object
@{
  slot x : Int = 0
  slot y : Int = 0
@}
@end example

The assign value is the slot's default value which is used when an instance
of the type is created.

There are no constructors in Heather and they are seldomly needed (since
slots are initialized by default).  If one needs additional
initialization code it is possible to add a init hook to the type using
the @code{on init} directive.

@findex on init
@findex init
@deffn Handler on @code{init} (@var{self}) @var{expr}
The @code{on init} hook is called as part of the instance
initialization.  Directly after instance allocation and binding of
init values to the instance's slots the init hook is called.  As single
argument the instance is passed to @var{self}.

@example
def class ProxyBridge : Object
@{
  on init(self)
  @{
  @}
@}
@end example
@end deffn

By default Heather creates the necessary @code{apply()} implementation
for each type.  Slots can be flagged in a way that they appear as keyed
parameters in an appropriate generic apply function:

@example
def class SenseOfLife : Object
@{
  slot x : Int = 6, key-init: 'x
  slot y : Int = 7, key-init: 'y
@}

-- the followig method is generated by the compiler
def meth apply(self : @@ SenseOfLife, x : Int = 6, y : Int = 7)
  @emph{body}
@end example

Instances of SenseOfLife can be created now like:

@example
SenseOfLive(x: 6, y: 7)
SenseOfLive(y: 7)
SenseOfLive()
@end example

It is also possible to flag slots to appear as positional arguments in
the @code{apply} generic:

@example
def class SenseOfLife : Object
@{
  slot x : Int = 6, init: 1
  slot y : Int = 7, init: 0
@}

-- result in
def meth apply(self : @@ SenseOfLife, y : Int, x : Int)
  @emph{body}
@end example

Slots appear in the @code{apply} function signature in the order as
specified by the numerical 0-based index parameter to the @code{init:}
flag.

For special constructors you can define and implement your own
@code{apply} methods for your type of course.  Heather will only create
@code{apply} functions if you don't do it yourself.


@c ....................................................................
@node Finalization, Array types, Slots, Types
@subsection Finalization

@cindex finalization
@cindex destructor
@findex on delete
@findex delete
@deffn Handler on @code{delete} (@var{self}) @var{expr}

It is possible to add special finalization code inside the type
declaration using the @code{on delete} directive.  Note that this is not
a real destructor (which is not necessary in Heather), but a kind of
finalization which is only necessary to free (external) resources.

As single argument the instance is passed to @var{self}.

@example
def class ProxyBridge : Object
@{
  on delete(self)
  @{
  @}
@}
@end example
@end deffn

@c ....................................................................
@node Array types, Parameterized types, Finalization, Types
@subsection Array types

Every type can exist as simple or as @dfn{array type}.  Arrays are
nevertheless first class objects.

@example
let buffer : Char[]        [1]
let tmp : Int[10]          [2]
@end example

[1] defines @code{buffer} as an array of unspecified size.  The initial
value is @emph{not} @code{#nil}, but an empty array of characters.  With
[2] the variable @code{tmp} is initialized to an array of 10 integers.
Not that the size of an array is not intergral part of the type, nor is
it a constraint (see below).


@c ....................................................................
@node Parameterized types, Constraint types, Array types, Types
@subsection Parameterized types

Types can be parameterized.  The parameters are types themselves.  Other
than @code{C++} or @code{D} templates there's only one type instance in
heather however.

@example
def class Pair(One, Two)
@{
  slot one : One, init: 0
  slot two : Two, init: 1
@}
@end example

To allocate a new instance of such a class the parameters must
specified:

@example
let p = Pair(Int, Real)(5, 7.0)
@end example

Note the double parantheses in the last example -- the first pair is for
the type parameters, the second for the values of the instance.  Note
that with such a definition the type @code{Pair} cannot be allocated as
instance -- simply the type parameters are required.   It is possible to
define default values of the types parameters however:

@example
def class Pair(One = Any, Two = Any)
@{
  slot one : One, init: 0
  slot two : Two, init: 1
@}
@end example

Then the following allocation is possible:

@example
let p = Pair()(5, 7.0)
@end example

Parameterized types can be used to specialize methods:

@example
def meth do-y(self : @@ Pair(Int, Int)) ...   [1]
def meth do-y(self : @@ Pair()) ...           [2]
def meth do-y(self : @@ Pair) ...             [3]
@end example

The case [1] will match for and Int-Int-Pair only, the case [2] matches
for Any-Any-Pair.

Case [3] is a special case.  Effectively the case [3] implementation
behaves like [2] (i.e. a Pair(Any, Any)) matches during runtime.  But
during compilation the calling code of such a method will treat it as if
it would have been called using proper type parameters.  Take the
following example:

@example
def meth distance(self : @@ Pair) ...

def x(offset : Int)
  let p : Pair(Int, Int)
  distance(p) + offset
@end example

In the implementation of @code{x()} the compiler does not know about the
return type of @code{distance()} and cannot optimize or check whether
the @code{+} operator is used correctly -- since the method definition
of @code{distance} is incomplete.  Here a special notation on the method
definition is used:

@example
def meth distance(value : @@ Pair) : value.Type.One ...

def x(offset : Int) : Int
  let p : Pair(Int, Int)
  distance(p) + offset
@end example

Here the definition of @code{distance()} tells the compiler that the
type of the returnvalue of the method will be the same as the type of
the @code{One} type parameter of the type of the @code{value} parameter
of the method.  In the body of @code{x()} @code{distance()} is called
with a value of type @code{Pair(Int, Int)}, therefore the compile can
deduce that the call of @code{distance()} will actually return an
@code{Int}.

This kind of type checking is happening from the caller side of course
only -- inside of the @code{distance()} method the compiler can only
deal with an @code{Pair(Any, Any)} type information, unless (as in case
[1]) the method is specialized with different type parameters.


@c ....................................................................
@node Constraint types, Union types, Parameterized types, Types
@subsection Constraint types

A @dfn{Constraint Type} is a type which is constrained a certain subset
of possible values.  Examples are numerical values only accepting
specific value ranges, collections only accepting certain values, etc.

@example
(Bool = #t)
(Int = -127 .. 127)
(Keyword = #['apple, 'pear, 'orange, 'banana, 'grapefruit])
@end example

The constraints are is used during compilation to detect type mismatched
and for possible optimization, but is not an integral part of the type
and therefore not used for multiple dispatch.  I.e. two constraint types
only differing in their contrains won't be treated differently during
multi dispatch.  The following code is wrong therefore:

@example
def meth do-x(a : @@ (Int = -127 .. 127)) ...
def meth do-x(a : @@ (Int = -16767 .. 16767)) ...
@end example


@c ....................................................................
@node Union types, Function types, Constraint types, Types
@subsection Union types

Union types declare that a variable, parameter or such may be of any
type defined in the union type.  Union types are most likely usefull
when defining methods which are appropriate for various types, which are
not directly related.

@example
def meth ->xml(val : @@ (IntNode, StringNode, BoolNode)) : String
  StringBuffer().append("<x>")
                .append(val.->string)
                .append("</x>")
                .->string
@end example

Another common usecase for union types are return values:

@example
def alias NumberOrFalse = (Number, Bool = #f)
@end example

Other than constraint types union types influence multiple dispatch.


@c --------------------------------------------------------------------
@node Function types,  , Union types, Types
@subsection Function types

@example
def f : (Function(a : Int) : Bool)
@end example


@c --------------------------------------------------------------------
@node Variables, FunctionCalls, Types, Specification
@section Variables and Constants

@example
def const %page-width% = 21
def port = *stdout*
@end example

Fluid variables (which ignore lexical scoping):

@example
def fluid *stdin* = <io>Cport(0)
def fluid *stdout* = <io>Cport(1)
def fluid *stderr* = <io>Cport(2)
@end example

Such fluid variables can be set later with @samp{let fluid x} to change
temporarily their value:

@example
def fluid x = 5

def g()
  outln(x)

def f()
  outln(x)
  @{
    let fluid x = 11
    g()
  @}
  outln(x)

@result{} 5
   11
   5
@end example



@c --------------------------------------------------------------------
@node FunctionCalls, SlotAccess, Variables, Specification
@section Function calls

Function calls:

  f(a, b, c)

Even if calling a generic function this pattern is kept.  To enhance
readability (and remove parantheses chains) the following form

  a.f(b, c)

is rewritten into

  f(a, b, c)

Additional functions without parameter don't need the parantheses.
Therefore

  f(g(h(i, j)))

is identical to

  h(i, j).g.f

Or

  self.name.empty?('force)

is identical to

  empty?(name(self), 'force)         by:    self.name.empty?('force)
                                         => name(self).empty?('force)
                                         => empty?(name(self), 'force)


@c --------------------------------------------------------------------
@node SlotAccess, Namespaces, FunctionCalls, Specification
@section Access to type slots

Since methods/functions are not bound to type, access is always to be done
explicitly to a typed reference:

@example
def class Point
@{
  slot x = 0
  slot y = 0
@}

def add(self : @@ Point, val : @@ Int)
  self.x = self.x + val
  self.y = self.x + val
  self

def add(self : @@ Point, val : @@ Point)
  self.x = self.x + val.x
  self.y = self.x + val.y
  self
@end example

How is this .x and .y implemented?  By default the compiler generates the
relevant access code.  You can overwrite accessors and mutators by
functions.  To access the slots you have to use the slot() and slot!()
special forms:

@example
def x(self : @@ Point)
  self.slot(x)                    -- identical to slot(self, 'x)


def x!(self : @@ Point, val)
  self.slot(x) = val              -- identical to slot!(self, 'x, val)

@end example

The "self.x" and "self.x =" syntax forms are translated into

@example
self.x      ->   x(self)
self.x = 5  ->   x!(self, 5)
@end example


@c --------------------------------------------------------------------
@node Namespaces, Import, SlotAccess, Specification
@section Namespaces

Declare and use the @dfn{namespace} of a @sc{compile unit}:

@example
namespace heather("eyestep/heather 1.0:core")
@end example

This sets the namespace for the following functions, types, macros, and
variables.  It is valid until the end of the source file or the next
namespace declaration.

Namespaces have two names, the short (or ``tag'') name and the full id
(the ``full name'').  The full name is any identifying string; for the
default heather libraries this is a kind of public id, other projects
may use URLs, etc.  Namespaces are compared by full id only, but since
this can be clumsy in code normally the tag name is used.  The common
tag @code{<io>} is actually defined as:

@example
namespace io("eyestep/heather 1.0:input-output")
@end example

If names are unique throughout all namespaces visible in a certain portion
of code there's no need to indicate the namespace.  If there are multiple
equally named functions or types in different namespaces however the fully
qualified name has to be used:

@example
<io>InputPort()
<zip>InputPort()
@end example

gives the @code{InputPort} type from the @code{io} and the @code{zip}
namespace respectively.

The namespace have to be given inside of method call chains also if
necessary:

@example
self.<io>write()
@end example

A namespace statement without full id data like

@example
namespace io
@end example

simply switches the current governing namespace to @code{io}.  It
requires a previous full namespace declaration, and is therefore usefull
for source files with multiple namespaces.

Namespace defines (i.e. tag name to full id mapping) are imported from
loaded files; the namespace defined in the file does not extend,
however, into the importing file.


@c --------------------------------------------------------------------
@node Import, Blocks, Namespaces, Specification
@section Import

Importing external modules.  The statement

@example
import(io)
@end example

will try to look for a module (file) @code{io} in the search path and
load it.


@c --------------------------------------------------------------------
@node Blocks, Loops, Import, Specification
@section Blocks

Code blocks are sequences of statements.  The last statement's return value
gives the return value of the complete block.  Blocks are atomic and
therefore can be put whereever a single expression is expected (i.e. even
in default parameter init value places):

@example
def f(x = @{ let p = Properties()
            while (p.next?) @{
              if (not p.nil?)
                break(p.value)
            @}
            else
              #f
          @})
   @emph{body}
@end example


@c --------------------------------------------------------------------
@node Loops, Conditionals, Blocks, Specification
@section Loops

@example
for (@emph{base}, @emph{conditions}) @emph{expr}
while (@emph{test}) @emph{expr}
until (@emph{test}) @emph{expr}
@end example

The returnvalue of @emph{expr}'s last statement gives the return value
of the complete loop statement.  Each loop form takes an optional
@code{else} branch, which is evaluated if the loop's body is never
entered:

@example
let first-name = for (n in values, not n.nil?)
                   break(n)
                 else
                   #nil
@end example

If no @code{else} branch is given the return value of such is a loop is
@code{#f}.


@c --------------------------------------------------------------------
@node Conditionals, Ranges and Slices, Loops, Specification
@section Conditionals

@deffn Special if (@var{test}) @var{consequent}
@deffnx Special if (@var{test}) @var{consequent} @code{else} @var{alternate}
@end deffn

@deffn Special select ([@var{value}]) { @var{tests} }
@deffnx Special select ([@var{value}]) { @var{tests} } @
        @code{else} @var{alternate}

@example
select (test) @{
  test -> expr
  test -> expr
@}
else
   expr
@end example

@example
select (a) @{
  \a -> if (not done)
          do-it
        else
          do-something-different
@}
else outln("nothing applies")
@end example

If the parameter list for select is empty each test is expected to be a
conditional expr:

@example
select () @{
  (c == \a or
   c == \b or
   c == \c)            -> @emph{expr}
  (c in #[\a, \b, \c]) -> @emph{expr}
@}
@end example
@end deffn


@c --------------------------------------------------------------------
@node Ranges and Slices, On-the-fly iterators, Conditionals, Specification
@section Ranges and Slices

Basic ranges are exclusive, so the range [5, 100) is written as:

@example
5 .. 100
@end example

Whereas [5, 100] is written as:

@example
5 ... 100
@end example

Give the step parameter:

@example
5 .. 100 by 5
@result{} 5, 10, 15, ..., 95
@end example

Ranges are used for instance to slice vectors and strings:

@example
"hello world"[3 .. 6]
@result{} "lo "

"hello world"[3 ... 6]
@result{} "lo w"

"hello world"[3 .. 8 by 2]
@result{} "l o"
@end example


@c --------------------------------------------------------------------
@node On-the-fly iterators, Conditions, Ranges and Slices, Specification
@section On the fly iterators

The @code{then-while} operators are used to express iterators on the
fly:

@example
for (i : Int = 0 then i + 1 while i < 10) @emph{body}

def value-iterators(values : Int[])
  let i = 0
  values[i] then values[i.incr!] while i + 1 < values.num-items
@end example



@c --------------------------------------------------------------------
@node Conditions, Closures, On-the-fly iterators, Specification
@section Conditions

It's possible to add a hook to a block which is called whenever the
block is left, either by unroll or by ``normal'' code flow:

@cindex exit handler
@findex on exit
@findex exit
@deffn Handler on @code{exit} (@var{value}) @var{expr}

Value is the return value of the block's last statement.  Normally the
exit handler will return this without modification.

Not that the @code{on exit} handler is actually inside the block for
which it is declared.  It can therefore access local bindings etc.  On
the other side in examples like this:

@example
let stream = <io>FileInputPort(name)
for (i = 0 .. 100) @{
  on exit(v)
  @{
    stream.close
  @}
  @emph{do-something}
@}
@end example

the exit hook would be called for each loop step.  The author mostly likely
intended this:

@example
let stream = <io>FileInputPort(name)
on exit(v)
@{
  stream.close
@}

for (i = 0 .. 100) @{
  @emph{do-something}
@}
@end example
@end deffn

Similar to @code{on exit} special conditions can be trapped:

@cindex exception handler
@findex on signal
@findex signal
@deffn Handler on @code{signal} (@var{value} @code{:} @var{type}) @
       @var{signal-expr}

This declares a condition handler for a condition of type @var{type}.
Whenever a condition raised (using @code{raise}) the first matching
condition handler is called.
@end deffn

During evaluation of @var{signal-expr} two special functions are
available: @code{continue(val)} and @code{raise()} without parameter.

@defun continue (@var{value})
Returns to the place from which @code{raise()} was
called injecting @var{value} as new returnvalue to the raise expression.
@end defun

@defun raise ([@var{condition}])
When called without parameter propagates the condition handling to the
next matching condition handler.  @code{raise()} without parameter does
not start a new condition signal chain, but passes control upwards.

When called with parameter @var{condition} is raised and a new signal
chain is started, which can be handled inside the control handler.
@end defun

If the condition handle is neither left early with @code{continue} or
@code{raise} the stack is unrolled and @var{signal-expr}'s return
value becomes the return value of the block in which the condition
handler has been declared.

If both exit and condition handler had been declared, the condition
handler is called first and its return value is passed as input to the
exit handler.


@c --------------------------------------------------------------------
@node Closures, Macros, Conditions, Specification
@section Closures

@example
#function(a : Real, b : Real) : Int @{ @}
@end example


@c --------------------------------------------------------------------
@node Macros, Ideas, Closures, Specification
@section Macros

Different kind of macro styles:

FUNCTION MACROS.

Look exactly and are called like functions:

  def macro min @{
     @{ min (?a:*, ?b:*) @} -> @{ @{ let tmp-a = ?a tmp-b = ?b
                                 if (tmp-a > tmp2) tmp-b else tmp-a @} @}
  @}

or in a local scope:

  let macro min @{
     @{ min (?a:*, ?b:*) @} -> @{ @{ let tmp-a = ?a tmp-b = ?b
                                 if (tmp-a > tmp2) tmp-b else tmp-a @} @}
  @}

usage:

  min(100, 200)


DEFINITION MACROS

Look like a define and/or let:

  def macro functional-variable @{
      @{ def functional-variable ?name:id = ?e:expr @} ->
        @{ def ?name ## -var = ?e
          def ?name () ?name ## -var
          def ?name (value) @{ ?name ##-var = value
                                 value @} @}
      @{ let functional-variable ?name:id = ?e:expr @} ->
        @{ let ?name ## -var = ?e
          let ?name () ?name ## -var
          let ?name (value) @{ ?name ##-var = value
                              value @} @}
  @}

STATEMENT MACROS

Look like a statement like for, while, etc.

  def macro unless @{
      @{ unless (?test:expr) ?b:body @} -> @{ if (not(?test)) ?b @}
  @}


  def macro with-open-file @{
    @{ with-open-file (?stream:id, ?name:string) ?e:expr @} ->
      @{
        let ?stream = FileInputPort(?name, 'read)
        on exit(value) @{
          if (?stream.nil?) close(?stream)
          value
        @}

        ?e
      @}
  @}


Multiple variant patterns and subpatterns:

  def macro funcvar @{
    @{ def funcvar ?name:id @} -> @{ def ?name ## -var = #nil
                                  def ?name () ?name ## -var
                                  def ?name (value) @{ ?name ## -var = value
                                                      value @} @}
    @{ def funcvar ?name:id = ?e:expr @} ->
                                @{ def ?name ## -var = ?e
                                  def ?name () ?name ## -var
                                  def ?name (value) @{ ?name ## -var = value
                                                      value @} @}
  @}

is identical to:

  def macro funcvar @{
    @{ def funcvar ?name:id #?opt-expr @} ->
                      @{ def ?name ## -var = ?opt-expr
                        def ?name () ?name ## -var
                        def ?name (value) @{ ?name ## -var = value
                                            value @} @}

  opt-expr:
    @{ @} -> @{ @}
    @{ = ?e:expr @} ->  @{ ?e @}
  @}


Conditional evaluation of macros (meta programming):

  def macro compile-only-if @{
    @{ compile-only-if(?test:bool) ?e:expr @} ->
      @{
        #if (?test)
          ?e
      @}
  @}


  basic constructs like if, else, let can be set and evaluated during
  macro-expansion time.  The form is then called: #if, #else, #let.  For
  the example above ?test **must** be a constant (or another macro
  expanding to a constant), since runtime code is not evaluated during
  macro expansion of course.


Optional macro parameters:

  def macro xxx @{
    @{ xxx(x: ?a = 5, y: ?b = 6) @} -> @{ yyy(m: ?a, n: ?b) @}
    @{ xxx(args ...) @} -> @{ yyy(args) @}
  @}


@c --------------------------------------------------------------------
@node Ideas, ReserverdWords, Macros, Specification
@section Ideas

@subsection Multiple returnvalues

@example
def f()
   (1, 2, 3, 4)

def g()
  let (a, b, c, d) = b.<io>Port().read(4)
@end example


@subsection Measures
@emph{Idea only.}

@example
21'cm
12.15'ft
21'm/s
412'px

def measure cm
def meth transform(from : @@ Measure(cm), to : @@ Measure(mm))
  Measure(from.value * 100, mm)
@end example


@c --------------------------------------------------------------------
@node ReserverdWords, Examples, Ideas, Specification
@section Reserved keywords

@code{alias} @code{and} @code{by} @code{class} @code{const} @code{def}
@code{else} @code{fluid} @code{for} @code{if} @code{in} @code{let}
@code{macro} @code{meth} @code{mod} @code{namespace} @code{or}
@code{select} @code{slot} @code{slot!} @code{type} @code{until}
@code{while}


@c --------------------------------------------------------------------
@node Examples,  , ReserverdWords, Specification
@section Examples

@example
namespace heather

----------------------------------------------------------------------
-- a pair class

def class Pair(Car, Cdr) : (Serializable, Copyable)
@{
  slot car : Car = #nil
  slot cdr : Cdr = #nil
@}

def meth ->string(self : @@ Pair) : String
  Stringbuffer().append("#<pair ",
                        self.car.->string,
                        " . ",
                        self.cdr.->string,
                        ">").->string

-- can be instantiated with
-- Pair(car: "hello", cdr: "world")
@end example


@example
----------------------------------------------------------------------
-- a point class

def class Point(Object,
    x : Int
    y : Int)

def meth distance(p1 : @@ Point, p2 : @@ Point) : Real
  let square(n) n ^ 2

  sqrt(square(p2.x - p1.x) + square(p2.y - p1.y))


def distance(x1, y1, x2, y2)
  let square(n) n ^ 2

  sqrt(square(x2 - x1) + square(y2 - y1))


-- can be instantiated with
-- Point(0, 127)
@end example


@example
----------------------------------------------------------------------
-- standalone function:

def with-open-input-file(name, proc)
  let stream = File-Input-Port(name)
  on exit(value) @{
    if (stream is nil)
      close(stream)
    value
  @}

  proc(stream)
@end example


@c ====================================================================
@node Copying, Function Index, Specification, Top
@include fdl.texinfo


@c ====================================================================
@node Function Index, Concept Index, Copying, Top
@unnumbered Index of functions

@printindex fn

@c ====================================================================
@node Concept Index,  , Function Index, Top
@unnumbered Index of concepts

@printindex cp

@shortcontents
@contents
@bye

