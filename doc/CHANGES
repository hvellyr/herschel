Visibility, export

  - Review module vs. interface again.
    Why do we need the "interface" specification?

  - What does "exporting" mean?  What does "public", "protected", "final"
    mean?

  - import outside or inside of "module" scope and effects on visibility


  Basic findings:

  - definitions from the embedding file are not visible in the embedded
    file.  I.e. embedded files are closures against the embedding context,
    they include their embedded files however.  I.e. also that exporting
    works always upwards (i.e. to the embedding context, not to the
    embedded context).

  - files imported inside a module scope are never visible to the outside of
    the module scope, even with exports in effect.  This is the way to
    encapsulate "private" imports from polluting public interface space.

  - importing into a module scope does not affect the overall namespace or
    module scope of the imported definitions; importing is about visibility
    not about inclusion.  For example importing a module "b" inside of
    module "a" does not result in definitions of effective module scope
    "a.b", but only in definitions of module "b" being visible in module
    "a", without a file "c" necessarily have to deal with "b" definitions
    when importing "a".

  - exports are used to make definitions from inside the module scope
    visible to the outside.

    export public(...)
    export outer(...)
    export inner(...)

      Makes the listed symbols (or all if *) visible to the outer or inner
      scope of the module, resp.  The outer/inner scopes are defined as in
      the following chart:

      +--------------------------------------------+
      |Embedding file A                            |
      |                                            |
      |   +--------------------------------------+ |
      |   |File B                                | |
      |   | +----------------------------------+ | |
      |   | |module m1                         | | |
      |   | | +--------------------------------+ | |
      |   | | |module m11                      | | |
      |   | | |                                | | |
      |   | | |                                | | |
      |   | +-+--------------------------------+ | |
      |   |                                    | | |
      |   | +----------------------------------+ | |
      |   | |module m2                         | | |
      |   | | +--------------------------------+ | |
      |   | | |module m21                      | | |
      |   | | | +------------------------------+ | |
      |   | | | |module m211                   | | |
      |   | | | |                              | | |
      |   | | | |                              | | |
      |   | | +-+------------------------------+ | |
      |   | |                                  | | |
      |   | | +--------------------------------+ | |
      |   | | |module m22                      | | |
      |   | | |                                | | |
      |   | +----------------------------------+ | |
      |   +--------------------------------------+ |
      +--------------------------------------------+

      Definitions of "m11" are not visible to anybody unless exported
      (simply as export (*), for instance).  The same applies to m21-m2,
      m211-m21, and m22-m2.  m211 is not visible to m2 however.  m22 is not
      visible to m21, to m211, to m11, or to m1, neither is m2 visible to
      m1.

      To make definitions visible to sibling modules (and their submodules)
      only export to "inner" (the inner circle of relations).  To make
      definitions visible to all modules up to the file (compile unit)
      level export to "outer" (the outer circle).  To make definitions
      visible to all export to "public".

    - symbols defines outside of a (formal) module are nevertheless subject
      to visibility control.  They must also be exported with 'export
      public' to be visible outside of this compile unit.


| - files imported behave by definition as "interface", i.e. included
|   implementations are **not** part of the importing compile unit.  Only
|   the definitions of the imported file are actually imported.  (Note:
|   macros are imported as "code", however, since macros are evaluated
|   directly.  The same applies for char name and config variable
|   definitions.)
|
|   In this way we don't really need the "interface" keyword, since a
|   module behaves silently as interface if imported.  The compiler must
|   make sure however that two type/class definitions match if coming from
|   **interface** (i.e. imported) and module definition.  The rule is than
|   that if the compiler finds a symbol redefinition only must come from a
|   compile unit, all others must origin from imported files.  The
|   interface version may be reduced however (no "on init", no "on delete",
|   not slot init values, only abstract generic functions, etc.).

  - exporting as "final" declares a symbol to be not extensible.  It can be
    combined with any of the visible keywords:

      export public (init) as final

    Definitions from a submodule can be exported as final to enclosing
    modules without changing visibility like this:

      export (init) as final


  - symbols to be exported take the form:

    *             - affects all symbols, normal, char, and units
    name          - export the normal symbol name (types, vars, etc.)
    name : char   - export the char definition 'name'
    name : unit   - export the unit definition 'unit'


Lazy evaluation

  The typical log problem.  The string is created before we decide whether
  we should log.  Either use macros:

    def macro log
    {
      { log(?level:expr, ?msg:expr) } -> { if (should-log(?level))
                                             log-impl(?msg)
                                         }
    }

  Or support lazy evaluation.  Since we will have the notion of "promises"
  anyway (for spawn and synchronization), this can be made first class:

    def log(level : Keyword, lazy msg : String)
      if (should-log(level))
        do-whatever-is-necessary(msg)

  Technically this can be done by the compiler as such.  The following
  example:

    log(#debug, StringBuffer().append("error ")
                              .append(exc.to-string)
                              .append("(").append(exc.details).append(")")
                              .to-string)

  can be compiled as:

    log(#debug, {
                  let msg = nil

                  function() : String {
                    if (msg.nil?) 
                      msg = StringBuffer().append("error ")
                                          .append(exc.to-string)
                                          .append("(").append(exc.details).append(")")
                                          .to-string
                    msg
                  }
                })

  The log-implementation would look like:

    def log(level : Keyword, lazy msg : String)
      if (should-log(level))
        do-whatever-is-necessary(msg())



Embedding C and C++ fragments.

  In the C extern it is only allowed to embed function definitions.  In the
  C++ embed it is possible also to embed class definitions ... but no code.

  extern ("C") {
    size_t fprintf(FILE* stream, const char* format, ...);
  }

  extern ("C++") {
    ...
  }


Function contracts

  Functions can be annotated by pre and post conditions.  These are
  actually part of the function signature and can be specified for abstract
  functions only.  Specialization must at least fulfill these contracts:

    def generic register-foo(reg @ Registry, foo @ 'T) : Registry
        where T isa Copyable
        on in foo <> nil
        on out(r) reg.key?(foo.name) and r == reg
     reg.put(foo.name, foo)
     reg

  These "on in" and "on out" statements are evaluated on entrance and exit
  of the function resp.  Only if both evaluate to true the contract is
  fulfilled, otherwise and AssertException is thrown.

  The "on out" statement is run after an "on exit" statement, where the
  function body's return value is passed in as 'r'.

  Another way to put pre and post conditions to functions is to declare an
  "on assert" statement in a class.  Such class invariants are run if a
  class instance is passed to the "assert" function:

    def class Date(d : Int, h : Int)
    {
      def slot day : Int = d
      def slot hour : Int = h

      on assert (c) {
        assert(1 <= day and <= 31)
        assert(0 <= hour and hour < 24)
      }
    }

    def generic add-day(date @ Date, day : Int) : Date
        on in assert(date)
        on out(r) r <> date and assert(r)
      Date(date.day + day, date.hour)

  The "on assert" statement is automatically called as last command from
  the class constructor, i.e. even after an "on init" statement.  

  Pre and post conditions are normally not compiled in release versions.


Used character in the Ascii table:

    Heather                             C
-------------------------------------------------------------
!   identifier                          not
"   string separator                    string
#   keyword notation                    preproc
    constant array notation
$   identifier                          [----------]
%   identifier                          operator (mod)
    operator (fold)
&   Complex type notation               operator (&, &&)
    Clone in call-by-value              pointer ref op.
'   Implicit type generics              char
    Units
()  arguments                           arguments
    grouping
*   operator (*, **)                    operator(*)
    identifier                          pointer ref op.
+   operator (+, ++)                    operator(+)
    identifier
,   parameter separator                 prm separator
-   identifier                          operator (-)
    operator (-)
    negative numbers
    comment starter (--)
.   function call                       struct member
    float notation                      float notation
    operator (..)
    vararg notation (...)               vararg notation (...)
/   operator (div)                      operator(div)
    identifier
0-9 digits                              digits
    identifier                          identifier
:   keyword arguments                   ternary operator
    type separator
;   Extended slot params                stmt terminator
<>  operator (<, >, <=, >=, <>, ->)     operator(...)
    parametrization
=   operator (==, <=, >=)               operator(==)
    assignment                          assignment
    parameter default
?   identifier                          ternary operator
    macro variable marker
@   specialize marker                   [----------]
A-Z digits                              digits
    identifier                          identifier
[]  slicing                             array
    arrays
\   char constants                      escaping
^   call-by-reference                   operator (xor)
_   identifier                          identifier
    current type notifier
`   [----------]                        [----------]
a-z digits                              digits
    identifier                          identifier
{}  code block                          code block
|   modname separator                   operator (|, ||)
    select/match case marker
~   docstring limiter                   operator (bit not)


